<html lang="vi">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content="Ứng dụng Pomodoro hỗ trợ học tập với tích hợp Gemini AI và giao diện hiện đại." />
    <title>Pomodoro Study App — Tích hợp Gemini AI (Giao diện mới)</title>
    <style>
    /*
    =============================================
    POMODORO STUDY APP — PHIÊN BẢN GIAO DIỆN TẬP TRUNG (v1.0)
    =============================================
    */

    :root {
      /* Theme Dark (Mặc định) - Cập nhật từ file 2 */
      --bg: #0f1222;
      --panel: #171a2e;
      --panel-rgb: 23, 26, 46; /* Thêm biến RGB cho panel */
      --muted: #212646;
      --text: #f4f6ff;
      --sub: #b7c1ff;
      --acc: #6c8cff;
      --acc-rgb: 108, 140, 255;
      --acc-2: #27d3a2;
      --purple: #a78bfa;
      --warn: #ffb020;
      --danger: #ff5c7a;
      --shadow: 0px 1.8px 2.2px rgba(0, 0, 0, 0.054), 0px 4.3px 5.3px rgba(0, 0, 0, 0.077), 0px 8.1px 10px rgba(0, 0, 0, 0.095), 0px 14.5px 17.9px rgba(0, 0, 0, 0.113), 0px 27.2px 33.4px rgba(0, 0, 0, 0.136), 0px 65px 80px rgba(0, 0, 0, 0.19);
      --radius: 16px;
      --panel-opacity: 0.85;
      --gradient-border: linear-gradient(135deg, var(--acc), var(--acc-2));
    }
    
    /* === START: THÊM CÁC THEME MỚI === */
    [data-theme='light'] {
      --bg: #f5f0e8; --panel: #ffffff; --panel-rgb: 255, 255, 255; --muted: #eaddcf; --text: #4a4a4a; --sub: #8a817c; --acc: #d4a373; --acc-rgb: 212, 163, 115; --acc-2: #a3b18a; --warn: #e76f51; --danger: #d00000;
      --shadow: 0px 1.8px 2.2px rgba(0, 0, 0, 0.024), 0px 4.3px 5.3px rgba(0, 0, 0, 0.037), 0px 8.1px 10px rgba(0, 0, 0, 0.045), 0px 14.5px 17.9px rgba(0, 0, 0, 0.053), 0px 27.2px 33.4px rgba(0, 0, 0, 0.066), 0px 65px 80px rgba(0, 0, 0, 0.09);
      --panel-opacity: 0.9;
      /* Ngăn nền tối mặc định khi không có ảnh */
      --bg-image: none;
    }

    [data-theme='pastel'] {
      --bg: #fde2e4; --panel: #fff1f2; --panel-rgb: 255, 241, 242; --muted: #fad2e1; --text: #595260; --sub: #8c7a8a; --acc: #c78283; --acc-rgb: 199, 130, 131; --acc-2: #7ec4cf; --warn: #f9bf45; --danger: #d7263d;
      --shadow: 0 5px 20px rgba(200,150,150,0.2);
      --panel-opacity: 0.9;
      /* Ngăn nền tối mặc định khi không có ảnh */
      --bg-image: none;
    }
    
    [data-theme='lofi'] {
      --bg: #2a2a3e; --panel: #3c3c52; --panel-rgb: 60, 60, 82; --muted: #4d4d66; --text: #e0e0ff; --sub: #a0a0c0; --acc: #ff8c69; --acc-rgb: 255, 140, 105; --acc-2: #69c6ff; --warn: #ffd700; --danger: #ff6961;
      /* === Replaced external GIF with inline data URI (offline-safe) === */
      --bg-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nNjAwJz48ZGVmcz48bGluZWFyR3JhZGllbnQgaWQ9J2cnIHgxPScwJyB5MT0nMCcgeDI9JzEnIHkyPScxJz48c3RvcCBvZmZzZXQ9JzAlJyBzdG9wLWNvbG9yPScjMmEyYTNlJy8+PHN0b3Agb2Zmc2V0PScxMDAlJyBzdG9wLWNvbG9yPScjM2MzYzUyJy8+PC9saW5lYXJHcmFkaWVudD48L2RlZnM+PHJlY3Qgd2lkdGg9JzEwMCUnIGhlaWdodD0nMTAwJScgZmlsbD0ndXJsKCNnKScvPjwvc3ZnPg==');
      --panel-opacity: 0.8;
    }
    
    [data-theme='space'] {
        --bg: #000000; --panel: #1a1a2e; --panel-rgb: 26, 26, 46; --muted: #2a2a4e; --text: #e0e0ff; --sub: #b0b0e0; --acc: #00aaff; --acc-rgb: 0, 170, 255; --acc-2: #aaff00; --warn: #ffaa00; --danger: #ff0055;
        /* === Replaced external GIF with inline data URI (offline-safe) === */
        --bg-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4MDAnIGhlaWdodD0nNjAwJz48ZGVmcz48cmFkaWFsR3JhZGllbnQgaWQ9J2cnIGN4PSc1MCUnIGN5PSc0MCUnIHI9JzcwJSc+PHN0b3Agb2Zmc2V0PScwJScgc3RvcC1jb2xvcj0nIzBiMGIxYScvPjxzdG9wIG9mZnNldD0nMTAwJScgc3RvcC1jb2xvcj0nIzAwMDAwMCcvPjwvcmFkaWFsR3JhZGllbnQ+PC9kZWZzPjxyZWN0IHdpZHRoPScxMDAlJyBoZWlnaHQ9JzEwMCUnIGZpbGw9J3VybCgjZyknLz48L3N2Zz4=');
        --panel-opacity: 0.75;
    }
    /* === END: THÊM CÁC THEME MỚI === */

    *:focus-visible {
      outline: 2px solid var(--acc); outline-offset: 2px; border-radius: 4px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body {
      margin:0; 
      font-family: system-ui, -apple-system, 'Segoe UI Variable', 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', 'Inter', sans-serif; 
      
      background-color: var(--bg);
      background-image: var(--bg-image, radial-gradient(1200px 800px at 10% -10%, #20285b 0%, #0f1222 50%, #0b0e1a 100%));
      
      background-size: cover; 
      background-position: center; 
      color:var(--text); 
      transition: background 0.5s ease, color 0.5s ease, filter 0.5s ease;
      text-shadow: 0px 0px 5px rgba(0, 0, 0, 0.5);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      text-rendering: optimizeLegibility;
    }
    a{color:var(--acc)}

    .app{display:flex; min-height:100vh}
    
    .app-nav {
        width: 60px;
        padding: 16px 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 16px;
        z-index: 100;
    }
    .nav-btn {
        background: transparent;
        border: none;
        color: var(--sub);
        width: 44px;
        height: 44px;
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all .2s ease;
        position: relative;
    }
    .nav-btn:hover { background: var(--muted); color: var(--text); }
    .nav-btn.active { background: var(--acc); color: white; }
    .nav-btn svg { width: 24px; height: 24px; }
    .nav-btn .tooltip {
        position: absolute;
        left: 110%;
        top: 50%;
        transform: translateY(-50%);
        color: var(--text);
        padding: 4px 8px;
        border-radius: 6px;
        font-size: 12px;
        box-shadow: var(--shadow);
        white-space: nowrap;
        opacity: 0;
        visibility: hidden;
        transition: opacity .2s ease, visibility .2s ease;
        pointer-events: none;
        z-index: 200;
    }
    .nav-btn:hover .tooltip { opacity: 1; visibility: visible; }

    .app-content {
        flex: 1;
        padding: 24px;
        overflow-y: auto;
        max-height: 100vh;
    }

    .view { display: none; }
    .view.active { display: grid; gap: 24px; animation: fadeIn .3s ease; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

    .main.reloading { opacity: 0; transition: opacity 0.2s ease-out; }

    .panel-bg{
        background: rgba(23, 26, 46, var(--panel-opacity));
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border:1px solid rgba(255,255,255,.08);
    }
    /* Thêm các quy tắc border cho theme light/pastel */
    [data-theme='light'] .panel-bg, [data-theme='pastel'] .panel-bg { border:1px solid rgba(0,0,0,0.05); }
    [data-theme='lofi'] .panel-bg { border:1px solid rgba(255,255,255,0.1); }
    [data-theme='space'] .panel-bg { border:1px solid rgba(255,255,255,0.12); }


header.app-header{display:flex; align-items:center; justify-content:space-between; padding:10px 14px; border-radius:var(--radius); box-shadow:var(--shadow); margin-bottom: 24px; position: relative; z-index: 2000;}
    header .actions{display:flex; gap:8px; align-items:center}
    
    .btn {
      background: rgba(255, 255, 255, 0.08);
      color: var(--text);
      border: none; /* Sửa đổi: bỏ border mặc định */
      padding: 10px 14px;
      border-radius: 12px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      box-shadow: inset 0 -2px 0 rgba(0,0,0,0.08);
      font-weight: 600;
      transition: all .15s ease;
      position: relative;
      overflow: hidden;
    }
    .btn::before {
        content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
        border: 2px solid transparent; border-radius: 12px; background: var(--gradient-border) border-box;
        -webkit-mask: linear-gradient(#fff 0 0) padding-box, linear-gradient(#fff 0 0);
        -webkit-mask-composite: destination-out; mask-composite: exclude; opacity: 0; transition: opacity 0.3s ease;
    }
    .btn:hover::before { opacity: 1; }
    .btn:hover { background: rgba(255, 255, 255, 0.12); }
    .btn:active { transform: translateY(1px) scale(0.98); filter: brightness(1); }
    .btn:disabled { cursor: not-allowed; filter: brightness(0.8) saturate(0.5); }
    .btn.ghost { background: transparent; border: 1px solid rgba(255, 255, 255, 0.2); }
    .btn.ghost:hover { background: rgba(255, 255, 255, 0.1); border-color: rgba(255, 255, 255, 0.3); }
    .btn.acc { background: var(--acc); color: white; }
    .btn.warn { background: var(--warn); color: white; }
    .btn.danger { background: var(--danger); color: white; }
    .btn.small { padding: 6px 10px; font-size: 14px; border-radius: 9px; }
    .btn.small::before { border-radius: 9px; }
    .btn > svg { width: 16px; height: 16px; stroke-width: 2.5px; }

    /* === START: CẬP NHẬT GIAO DIỆN QUẢN LÝ CHỦ ĐỀ === */
    #view-topics { grid-template-columns: 1fr; }
    .topic-item { background:rgba(255,255,255,.04); border:1px solid var(--muted); border-radius:12px; padding:8px; margin-bottom:8px; } /* Sửa đổi */
    .topic-header, .sub-row { display:flex; align-items:center; gap:8px; position: relative; }
    .topic-header { cursor: pointer; }
    .topic-header .topic-actions { cursor: default; }
    .topic-header .topic-actions * { cursor: pointer; }
    .topic-item { cursor: pointer; }
    .topic-item .topic-actions { cursor: default; }
    .topic-item .topic-actions * { cursor: pointer; }
    .topic-title { flex:1; font-weight:600; cursor: pointer; }
    .chev { width:28px; height:28px; border-radius:8px; display:inline-flex; align-items:center; justify-content:center; flex-shrink: 0; cursor: pointer; }
    .chev .ico { display:inline-block; transition: transform .18s ease; }
    .chev[aria-expanded="false"] .ico { transform: rotate(-90deg); }
    .subtopics { margin-top:8px; display:flex; flex-direction:column; gap:6px; }
    .subtopics.hidden { display:none; }
    
    .topic-actions, .sub-row .actions {
        opacity: 0;
        visibility: hidden;
        transition: opacity .2s ease, visibility .2s ease;
        display: flex;
        gap: 6px;
        align-items: center;
    }
    .topic-item:hover .topic-actions, .topic-item:focus-within .topic-actions,
    .sub-row:hover .actions, .sub-row:focus-within .actions {
      opacity: 1;
      visibility: visible;
    }
    .actions-menu-btn {
        padding: 0;
        width: 28px;
        height: 28px;
        font-size: 1.2em;
        line-height: 1;
    }
    .actions-menu {
        position: absolute;
        top: 100%;
        right: 0;
        border-radius: 8px;
        padding: 6px;
        box-shadow: var(--shadow);
        z-index: 10;
        min-width: 150px;
        display: none;
        flex-direction: column;
        gap: 4px;
    }
    /* Nâng khối đang mở menu lên trên các khối khác */
    .topic-item.menu-active { position: relative; z-index: 20; }
    
    .actions-menu.show { display: flex; }
    .menu-item {
        background: transparent; border: none; color: var(--text);
        padding: 8px 10px; border-radius: 6px; text-align: left;
        width: 100%; cursor: pointer; transition: background .2s ease;
        display: flex; align-items: center; gap: 8px; font-size: 14px; font-weight: 500;
    }
    .menu-item:hover { background: var(--acc); color: white; }
    .menu-item.danger:hover { background: var(--danger); }
    /* === END: CẬP NHẬT GIAO DIỆN QUẢN LÝ CHỦ ĐỀ === */

    .subtopic-btn{
        flex:1; 
        text-align:left;
        background-color: rgba(0,0,0,0.02); /* Sửa đổi */
    }
    .subtopic-btn:hover {
        background-color: transparent; /* Hover transparent to avoid blue background */
    }
    .subtopic-btn.active{
        outline:2px solid var(--acc); 
    }
    .subtopic-btn.active:hover {
        background: transparent; /* Giữ nền trong suốt khi di chuột qua */
    }
    
    .panel{border-radius:var(--radius); padding:24px; box-shadow:var(--shadow)}

    .timer-header { display: flex; justify-content: space-between; align-items: center; gap: 12px; flex-wrap: wrap; }
    .timer{display:grid; gap:16px; grid-template-columns: 1fr; align-items:center; text-align:center}
    .big-time{font-size: clamp(60px, 12vw, 96px); letter-spacing:1px; font-weight:700; color: var(--text)}
    .state{font-weight:700; letter-spacing:.6px}
    .state.work{color:var(--acc-2)} /* Sửa đổi màu */
    .state.break{color:var(--warn)}
    .state.long{color:var(--danger)} /* Sửa đổi màu */
    .controls{display:flex; flex-wrap:wrap; gap:12px; justify-content:center}    
    #btnStart { padding: 14px 28px; font-size: 1.2em; }
    #btnPause, #btnResume { padding: 12px 24px; font-size: 1.1em; }

    /* === START: TÙY CHỈNH DẢI PHÂN CÁCH MỀM MẠI HƠN === */
    #view-timer .panel-bg hr {
        border: none; /* Bỏ đường viền mặc định */
        height: 1px;  /* Đặt chiều cao cho đường kẻ */
        background-color: var(--muted); /* Sử dụng màu phụ của theme */
        opacity: 0.3; /* Làm cho nó mờ đi, hòa vào nền */
        margin-top: 0; /* Điều chỉnh lại khoảng cách */
    }
    /* === END: TÙY CHỈNH DẢI PHÂN CÁCH MỀM MẠI HƠN === */

    .stats-grid{display:grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap:12px}
    .stat-card{background:rgba(255,255,255,0.04); border:1px solid var(--muted); border-radius:14px; padding:12px; text-align:center} /* Sửa đổi */
    .stat-card h4{margin:4px 0 8px; color:var(--sub); font-weight:600; font-size: 14px;}
    .stat-value{font-size: 20px; font-weight: 600;}
    .tiny{font-size:12px; color:var(--sub)}
    .history{display:grid; gap:8px; max-height:300px; overflow:auto; padding-right:6px}
    .hist-item{display:grid; grid-template-columns: 1fr auto; gap:10px; align-items:start; background:rgba(255,255,255,0.04); border:1px solid var(--muted); border-radius:10px; padding:10px} /* Sửa đổi */

    .row{display:flex; gap:8px; align-items:center}
    .row > * {flex:1}
    input[type="text"], input[type="password"], input[type="number"], select, textarea{width:100%; background:rgba(255,255,255,0.04); color:var(--text); border:1px solid var(--muted); border-radius:10px; padding:10px; outline:none}
    textarea{min-height:80px; resize: vertical;}

    .toasts{position:fixed; right:16px; bottom:16px; display:flex; flex-direction:column; gap:8px; z-index:9999}
    .toast{
        background: var(--panel); /* Sửa đổi */
        border:1px solid var(--muted);
        color:var(--text);
        padding:10px 12px; border-radius:12px; box-shadow:var(--shadow);
        animation: toast-in .3s ease; transform-origin: bottom right;
    }
    @keyframes toast-in { from { opacity: 0; transform: scale(0.8); } to { opacity: 1; transform: scale(1); } }

    .modal{position:fixed; inset:0; display:none; align-items:center; justify-content:center; background: rgba(0,0,0,var(--panel-opacity)); z-index:10000; backdrop-filter: blur(5px);} /* Nâng z-index để nằm trên header */
    .modal.show{display:flex}
    .modal-card{
        position: relative;
        z-index: 10001;
        width:min(720px, 94vw);
        border-radius:16px;
        padding:16px;
        box-shadow:var(--shadow);
        animation: modal-in .25s ease-out;
        max-height: 90vh;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
    }
    body.modal-open { overflow: hidden; }
    @keyframes modal-in { from { opacity: 0; transform: scale(0.92) translateY(10px); } to { opacity: 1; transform: scale(1) translateY(0); } }
    .modal-card h3{margin-top:0}
    .dashboard-table { width: 100%; border-collapse: collapse; margin-top: 12px; }
    .dashboard-table th, .dashboard-table td { padding: 8px 12px; text-align: left; border-bottom: 1px solid var(--muted); }
    .dashboard-table th { color: var(--sub); }

    .footer-note{font-size:12px; color:var(--sub)}
    .hidden{display:none !important}

    .notes-list { display: flex; flex-direction: column; gap: 8px; max-height: 250px; overflow-y: auto; padding-right: 6px; }
    .note-item { background: rgba(255,255,255,0.04); border-radius: 10px; padding: 10px; display: flex; justify-content: space-between; align-items: flex-start; gap: 10px; cursor: pointer; } /* Sửa đổi */
    .note-content-wrapper { flex: 1; min-width: 0; }
    .note-content { white-space: pre-wrap; word-break: break-word; max-height: 60px; overflow: hidden; position: relative; transition: max-height 0.35s ease-in-out; }
    .note-content:not(.expanded)::after {
        content: ''; position: absolute; bottom: 0; right: 0; width: 100%; height: 20px; background: linear-gradient(to top, var(--panel) 20%, transparent);
    }
    .note-content.expanded { max-height: 500px; }
    .note-meta { font-size: 11px; color: var(--sub); margin-top: 4px; }
    
    .spinner { border: 2px solid var(--muted); border-top-color: var(--text); border-radius: 50%; width: 16px; height: 16px; animation: spin 1s linear infinite; } /* Sửa đổi */
    @keyframes spin { to { transform: rotate(360deg); } }

    .panel-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
    .panel-header h3 { margin: 0; }
    .panel-header .actions { display: flex; gap: 8px; }
    
    .aux-panel { margin-top: 24px; }
    .tab-nav { display: flex; gap: 4px; border-bottom: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 16px; }
    .tab-btn { background: transparent; border: none; color: var(--sub); padding: 8px 16px; cursor: pointer; border-bottom: 2px solid transparent; transition: all .2s ease; font-weight: 600; }
    .tab-btn:hover { color: var(--text); }
    .tab-btn.active { color: var(--acc); border-bottom-color: var(--acc); }
    .tab-content {
      display: none;
      padding-top: 8px;
    }
    .tab-content.active {
      animation: fadeIn 0.25s ease-out;
    }
    #tasks.tab-content.active,
    #notes.tab-content.active,
    #ai.tab-content.active {
        display: block;
    }

    #settings-timer.tab-content.active,
    #settings-ui.tab-content.active,
    #settings-integrations.tab-content.active {
        display: flex;
    }

    .settings-row-toggle {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 16px;
    }
    .settings-row-toggle span {
      flex: 1;
      cursor: pointer;
    }
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 44px;
      height: 24px;
      flex-shrink: 0;
    }
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .toggle-switch .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: var(--muted);
      transition: .3s;
      border-radius: 24px;
    }
    .toggle-switch .slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: .3s;
      border-radius: 50%;
    }
    .toggle-switch input:checked + .slider {
      background-color: var(--acc-2);
    }
    .toggle-switch input:checked + .slider:before {
      transform: translateX(20px);
    }
    
    .chat-messages { max-height: 250px; overflow-y: auto; display: flex; flex-direction: column; gap: 8px; margin-bottom: 12px; padding: 4px; }
    .chat-msg { padding: 8px 12px; border-radius: 12px; max-width: 85%; word-break: break-word; }
    .chat-msg.user { background: var(--acc); color: white; align-self: flex-end; border-bottom-right-radius: 4px; }
    .chat-msg.model { background: var(--muted); align-self: flex-start; border-bottom-left-radius: 4px; }
    .chat-input-area { display: flex; gap: 8px; }

    .methods-list { list-style: none; padding: 0; }
    .method-item { align-items: flex-start; padding: 12px; display: flex; flex-direction: column; gap: 10px; border-radius: 8px; }
    .method-item:hover { background: rgba(0,0,0,0.03); } /* Sửa đổi */
    .method-item input[type="checkbox"] { width: 18px; height: 18px; margin-top: 2px; flex-shrink: 0;}
    .method-item label { flex: 1; }
    .method-item label.completed { text-decoration: line-through; color: var(--sub); }
    .method-item .content-wrapper { flex: 1; cursor: pointer; }
    .method-item .concept { font-size: 14px; color: var(--sub); margin-top: 8px; border-left: 2px solid var(--muted); padding-left: 12px; white-space: pre-wrap; word-break: break-word; }
    /* Highlight section titles and bold text inside method content */
    .method-content h4 {
        color: var(--acc-2);
        font-size: 1.1em;
        margin-top: 1.5em;
        margin-bottom: 0.5em;
        /* Giới hạn chiều rộng để tiêu đề gọn hơn */
        max-width: 50%;
    }
    .method-content strong {
        color: var(--acc);
        font-weight: 600;
    }
    /* Apply the same highlight to the Guide view */
    #view-guide h4 { color: var(--acc-2); }
    #view-guide strong { color: var(--acc-2); }
    /* Show hand cursor to indicate clickability */
    .method-item, .method-item summary { cursor: pointer; }
    .subtopic-todo-list { list-style: none; padding: 0; margin: 0; max-height: 100px; overflow-y: auto; text-align: left; }
    .subtopic-todo-list li { display: flex; align-items: center; gap: 8px; padding: 4px; transition: all 0.2s ease-out; }
    .subtopic-todo-list li.removing { transform: translateX(100%); opacity: 0; }
    .subtopic-todo-list label { flex: 1; }

    #youtube-player-container { position: absolute; top: -9999px; left: -9999px; width: 1px; height: 1px; overflow: hidden; }

    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.1); border-radius: 10px; } /* Sửa đổi */
    ::-webkit-scrollbar-thumb { background: var(--muted); border-radius: 10px; border: 2px solid transparent; background-clip: content-box; }
    ::-webkit-scrollbar-thumb:hover { background: var(--sub); background-clip: content-box; }
    
    .timer-circle-container {
        position: relative; width: clamp(250px, 40vw, 320px); height: clamp(250px, 40vw, 320px); margin: 24px auto; display: flex; align-items: center; justify-content: center;
    }
    .timer-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: rotate(-90deg); }
    .timer-circle-bg, .timer-circle-progress { fill: none; stroke-width: 8; }
    .timer-circle-bg { stroke: var(--muted); } /* Sửa đổi */
    .timer-circle-progress { stroke: var(--acc); stroke-linecap: round; transition: stroke-dashoffset 0.3s linear, stroke 0.5s ease; }
    @keyframes flash { 0%, 100% { box-shadow: 0 0 10px 2px transparent; } 50% { box-shadow: 0 0 20px 8px currentColor; } }
    .timer-circle-container.finished { color: var(--acc-2); animation: flash 1s ease-out; }
    @keyframes breathing-effect { 0% { transform: scale(1); } 50% { transform: scale(1.03); } 100% { transform: scale(1); } }
    .timer-circle-container.breathing { animation: breathing-effect 3s ease-in-out infinite; }
    
    
    
    @media (max-width: 1024px) {
      .app-content { padding: 20px; }
      .panel { padding: 20px; }
      .timer-circle-container { width: clamp(220px, 50vw, 300px); height: clamp(220px, 50vw, 300px); }
    }

    @media (max-width: 768px) {
      .app { flex-direction: column; }
      .app-nav { width: 100%; height: 60px; flex-direction: row; justify-content: center; border-right: none; border-top: 1px solid rgba(255,255,255,.08); order: 2; padding: 0 16px; }
      .app-content { padding: 16px; order: 1; }
      .panel { padding: 16px; }
      .modal-card .tab-nav { overflow-x: auto; }
    }

    @media (max-width: 480px) {
      .app-nav { height: 50px; }
      .nav-btn { flex: 1; }
      header.app-header { flex-direction: column; align-items: stretch; gap: 8px; }
      .btn { padding: 8px 12px; }
      .timer-circle-container { width: clamp(180px, 80vw, 220px); height: clamp(180px, 80vw, 220px); margin: 16px auto; }
      .panel { padding: 12px; }
      .app-content { padding: 12px; }
    }

    #view-timer.no-subtopic-selected > .panel-bg:not(:first-child) { display: none; }
    #view-timer.no-subtopic-selected .timer-header > .presets { display: none; }
    #view-timer.no-subtopic-selected .timer { display: none; }

    header.app-header .actions #btnFullscreen { background: transparent; border: none; box-shadow: none; }
    header.app-header .actions #btnFullscreen:hover { background: var(--muted); filter: none; }
    header.app-header .actions #btnFullscreen:hover::before { opacity: 0; }

    input[type="text"], input[type="password"], input[type="number"], select, textarea {
        background: rgba(255,255,255,0.04) !important; /* Sửa đổi: chuyển sang nền trắng trong suốt */
        color: var(--text);
        border: 1px solid rgba(255, 255, 255, 0.1); /* Viền trắng mờ */
        transition: background .2s ease, border-color .2s ease;
    }
    input[type="text"]:focus, input[type="password"]:focus, input[type="number"]:focus, select:focus, textarea:focus {
        background: rgba(255,255,255,0.06) !important; /* Tinh chỉnh: sát mẫu hơn */
        border-color: var(--acc);
    }
    /* === START: SỬA LỖI NỀN INPUT/SELECT TRÊN THEME SÁNG === */
    [data-theme='light'] input, [data-theme='light'] select, [data-theme='light'] textarea,
    [data-theme='pastel'] input, [data-theme='pastel'] select, [data-theme='pastel'] textarea {
        background: rgba(0, 0, 0, 0.05) !important; /* Dùng nền đen mờ thay vì trắng mờ */
        border-color: rgba(0, 0, 0, 0.1); /* Viền đen mờ trên theme sáng */
    }

    [data-theme='light'] input:focus, [data-theme='light'] select:focus, [data-theme='light'] textarea:focus,
    [data-theme='pastel'] input:focus, [data-theme='pastel'] select:focus, [data-theme='pastel'] textarea:focus {
        background: rgba(0, 0, 0, 0.07) !important; /* Tăng độ đậm khi focus */
    }
    /* === END: SỬA LỖI NỀN INPUT/SELECT TRÊN THEME SÁNG === */

    /* Cải thiện nền và màu chữ cho option trong select theo theme hiện tại */
    select option {
        background: var(--panel);
        color: var(--text);
    }
    
    ::placeholder { color: var(--sub); opacity: 0.7; } /* Sửa đổi */
    ::-ms-input-placeholder { color: var(--sub); }
    :-ms-input-placeholder { color: var(--sub); }

    
    
    .draggable-timer {
        position: fixed;
        bottom: 20px;
        right: 20px;
        color: var(--text);
        padding: 8px 16px;
        border-radius: 12px;
        box-shadow: var(--shadow);
        font-size: 2em;
        font-weight: 600;
        cursor: move;
        user-select: none;
        z-index: 9998;
        opacity: 0;
        transform: scale(0.9);
        pointer-events: none;
        transition: opacity 0.35s ease, transform 0.35s ease;
    }
    body.bg-view-mode .draggable-timer {
        opacity: 1;
        transform: scale(1);
        pointer-events: auto;
    }
    .app-nav, .panel-bg, .app-header .actions > *, .app-header > .row {
        transition: opacity 0.35s ease, transform 0.35s ease, background 0.35s ease, border-color 0.35s ease, box-shadow 0.35s ease;
    }
    body.bg-view-mode .app-nav,
    body.bg-view-mode .view.active > .panel-bg {
        opacity: 0;
        pointer-events: none;
        transform: scale(0.98);
    }
    body.bg-view-mode .app-header {
        background: transparent !important;
        border-color: transparent !important;
        box-shadow: none !important;
    }
    body.bg-view-mode .app-header .actions > *:not(#btnToggleBg),
    body.bg-view-mode .app-header > .row {
        opacity: 0;
        pointer-events: none;
    }
    body.bg-view-mode #btnToggleBg {
        opacity: 1;
        pointer-events: auto;
    }
    .sound-permission-bar {
      position: fixed; left: 50%; transform: translateX(-50%);
      bottom: 48px; z-index: 9999;
      border-radius: 12px; padding: 10px 14px;
      display: none; align-items: center; gap: 10px;
      box-shadow: var(--shadow);
    }
    .sound-permission-bar.show { display: flex; }

    /* ========================================================= */
    /* START: CẢI THIỆN GIAO DIỆN ÂM THANH (HTML Refactor)     */
    /* ========================================================= */

    #customSoundsContainer {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 16px;
      padding: 14px;
      border-radius: 12px;
      background: rgba(var(--panel-rgb), var(--panel-opacity));
      border: 1px solid rgba(255, 255, 255, 0.08);
      width: 100%;
    }

    .custom-sound-row {
      align-items: center;
      padding: 12px 16px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(var(--panel-rgb), calc(var(--panel-opacity) * 0.85));
      width: 100%;
      gap: 12px;
    }

    .custom-sound-row .custom-sound-label {
      flex: 1;
      margin: 0;
      font-size: 14px;
      color: var(--sub);
      font-weight: 500;
      cursor: default;
    }

    .custom-sound-row .btn[for] {
      flex-shrink: 0;
      margin-left: 12px;
      content: 'Tải lên';
    }

    [data-theme='light'] #customSoundsContainer,
    [data-theme='pastel'] #customSoundsContainer {
      border-color: rgba(0, 0, 0, 0.08);
    }
    [data-theme='light'] .custom-sound-row,
    [data-theme='pastel'] .custom-sound-row {
      border-color: rgba(0, 0, 0, 0.08);
      background: rgba(var(--panel-rgb), 0.85);
    }

    .custom-sound-row .custom-sound-label {
      flex: 1;
      margin: 0;
      font-size: 14px;
      color: var(--sub);
      font-weight: 500;
      cursor: default;
    }

    .custom-sound-row .btn[for] {
      flex-shrink: 0;
      margin-left: 12px;
      /* Văn bản hiển thị đã đặt trong HTML; khai báo content nhằm nhấn mạnh mục đích nút */
      content: 'Tải lên';
    }
    /* ========================================================= */
    /* END: CẢI THIỆN GIAO DIỆN ÂM THANH (HTML Refactor)         */
    /* ========================================================= */
    .sound-permission-bar .msg { font-size: 14px; color: var(--text); }
    .draggable-timer { text-shadow: 0px 0px 8px rgba(0, 0, 0, 0.9); }

    /* Giảm/loại bỏ bóng chữ cho theme sáng để tránh nhòe/lóa */
    body[data-theme='light'],
    body[data-theme='pastel'] { text-shadow: none; }
    body[data-theme='light'] .draggable-timer,
    body[data-theme='pastel'] .draggable-timer { text-shadow: none; }

    /* ============================================= */
/* ========================================================= */
/* START: THI?T L?P PANEL KI?U M?  ?C (FROSTED GLASS)        */
/* ========================================================= */

/* --- 1.  p d?ng hi?u ?ng n?n m? chung cho t?t c? c c panel --- */
.app-nav,
.panel-bg,
.modal-card,
.actions-menu,
.nav-btn .tooltip,
.draggable-timer, 
.sound-permission-bar,
.toast,
.topic-item,
.stat-card,
.hist-item,
.method-item {
    background: rgba(var(--panel-rgb), var(--panel-opacity));
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
}

/* --- 2.  ?nh nghia vi?n cho t?ng lo?i panel --- */
.app-nav {
    border-right: 1px solid rgba(255, 255, 255, 0.1);
}
.panel-bg,
.modal-card,
.actions-menu,
.nav-btn .tooltip,
.draggable-timer, 
.sound-permission-bar,
.toast,
.topic-item,
.stat-card,
.hist-item,
.method-item {
    border: 1px solid rgba(255, 255, 255, 0.1);
}

/* --- 3. Tinh ch?nh vi?n cho c c theme S NG (Light/Pastel) --- */
[data-theme='light'] .app-nav,
[data-theme='light'] .panel-bg,
[data-theme='light'] .modal-card,
[data-theme='light'] .actions-menu,
[data-theme='light'] .nav-btn .tooltip,
[data-theme='light'] .draggable-timer,
[data-theme='light'] .sound-permission-bar,
[data-theme='light'] .toast,
[data-theme='light'] .topic-item,
[data-theme='light'] .stat-card,
[data-theme='light'] .hist-item,
[data-theme='light'] .method-item,
[data-theme='pastel'] .app-nav,
[data-theme='pastel'] .panel-bg,
[data-theme='pastel'] .modal-card,
[data-theme='pastel'] .actions-menu,
[data-theme='pastel'] .nav-btn .tooltip,
[data-theme='pastel'] .draggable-timer,
[data-theme='pastel'] .sound-permission-bar,
[data-theme='pastel'] .toast,
[data-theme='pastel'] .topic-item,
[data-theme='pastel'] .stat-card,
[data-theme='pastel'] .hist-item,
[data-theme='pastel'] .method-item {
    border-color: rgba(0, 0, 0, 0.1);
}

/* --- 4. S?a l?i hi?u ?ng fade-out c?a ghi ch  cho ph  h?p --- */
.note-content:not(.expanded)::after {
    background: linear-gradient(to top, rgba(var(--panel-rgb), 1) 20%, transparent);
}

/* --- C c quy t?c c n l?i gi? nguy n t? file g?c --- */
[data-theme='light'] .tab-nav,
[data-theme='pastel'] .tab-nav {
    border-bottom-color: rgba(0, 0, 0, 0.1);
}
.subtopic-btn {
    background-color: transparent;
}
.subtopic-btn:hover {
    background-color: transparent; /* Hover transparent to avoid blue background */
}
/* Khi nội dung mở, thêm đường phân cách ở trên nội dung */
.method-item > .method-content:not([hidden]) {
    border-top: 1px solid rgba(255, 255, 255, 0.1);
    /* margin-top: 8px;  <-- Đã xóa */
    padding-top: 8px; /* <-- Giữ lại một chút padding để nội dung không dính vào đường kẻ */
}
    [data-theme='light'] .method-item > .method-content:not([hidden]),
    [data-theme='pastel'] .method-item > .method-content:not([hidden]) {
        border-top-color: rgba(0, 0, 0, 0.1);
    }

    /* Editor container (single pane, Rich Text) */
    .editor-container { height: 350px; }
    .editable-content { height: 100%; border: 1px solid var(--muted); border-radius: 10px; padding: 10px; overflow-y: auto; background: var(--bg); }
    .editable-content:focus-within { border-color: var(--acc); outline: none; }
    .editable-content h4 { color: var(--acc-2); font-size: 1.1em; margin-top: 1.5em; margin-bottom: 0.5em; }
    .editable-content strong, .editable-content b { color: var(--acc); font-weight: 600; }
    .editable-content ol, .editable-content ul { padding-left: 20px; }

    /* Editor toolbar for Methods modal */
    .editor-toolbar { display: flex; gap: 6px; margin-bottom: 6px; padding: 4px; background: var(--muted); border-radius: 8px; }
    .editor-toolbar button { font-weight: bold; width: 32px; height: 32px; padding: 0; }
    .editor-toolbar .btn.ghost:hover { background-color: rgba(var(--acc-rgb, 108, 140, 255), 0.15); }
    .editor-toolbar .btn.ghost.active { background-color: rgba(var(--acc-rgb, 108, 140, 255), 0.25); }
    .color-picker-wrapper { position: relative; }
    .color-palette { position: absolute; bottom: 110%; left: 50%; transform: translateX(-50%); display: flex; gap: 6px; padding: 6px; border-radius: 8px; border: 1px solid var(--muted); background: var(--panel); box-shadow: var(--shadow); z-index: 10; }
    .color-swatch { width: 24px; height: 24px; border-radius: 50%; border: 2px solid rgba(255, 255, 255, 0.5); cursor: pointer; transition: transform 0.15s ease; }
    .color-swatch:hover { transform: scale(1.15); }

    /* ========================================================= */
    /* START: CẬP NHẬT GIAO DIỆN TIÊU ĐỀ KHO TRI THỨC            */
    /* ========================================================= */

    /* Sử dụng Flexbox để căn chỉnh tiêu đề và các nút trên cùng một hàng */
    .method-item > div:first-child {
        display: flex;
        align-items: center;
        justify-content: space-between; /* Đẩy tiêu đề và các nút về hai phía */
        gap: 8px;
        width: 100%; /* Đảm bảo hàng tiêu đề chiếm đủ chiều rộng */
    }

    /* Cho phép tiêu đề co giãn để chiếm không gian và xử lý text dài */
    .method-item .method-title {
        flex: 1; /* Quan trọng: Cho phép tiêu đề chiếm hết không gian trống */
        min-width: 0;
        word-break: break-word;
        overflow-wrap: break-word;
        cursor: pointer;
    }

    /* Giữ lại quy tắc ẩn/hiện các nút hành động khi di chuột */
    .method-item .topic-actions {
        margin-left: 8px; /* Thêm một chút khoảng đệm bên trái */
    }

    .method-item:hover .topic-actions,
    .method-item:focus-within .topic-actions {
        opacity: 1;
        visibility: visible;
    }
    /* ========================================================= */
    /* END: CẬP NHẬT GIAO DIỆN                                  */
    /* ========================================================= */

    /* ========================================================= */
    /* START: SỬA LỖI TRÀN GIAO DIỆN VỚI VĂN BẢN DÀI (FLEXBOX FIX) */
    /* ========================================================= */
    .topic-title,
    .subtopic-btn,
    .note-content-wrapper,
    .subtopic-todo-list label,
    .method-title,
    .method-item > div:first-child { /* <--- Cho phép header Kho Tri Thức co lại */
        min-width: 0; /* Cho phép phần tử co lại nhỏ hơn nội dung của nó */
    }

    .topic-title,
    .subtopic-btn,
    .note-content,
    .subtopic-todo-list label,
    .hist-item > div,
    .method-title { /* <--- Bổ sung cho Kho Tri Thức */
        word-break: break-word;      /* Tự động ngắt các từ quá dài */
        overflow-wrap: break-word; /* Đảm bảo ngắt dòng cho chuỗi dài */
    }
    /* ========================================================= */
    /* END: SỬA LỖI TRÀN GIAO DIỆN VỚI VĂN BẢN DÀI (FLEXBOX FIX) */

    </style>
</head>
<body data-theme="default"> <div class="app" id="app">
    <nav class="app-nav">
        <button class="nav-btn active" id="navBtnTimer" data-view="timer" aria-label="Đồng hồ">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>
            <span class="tooltip">Đồng hồ</span>
        </button>
        <button class="nav-btn" id="navBtnTopics" data-view="topics" aria-label="Chủ đề">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1 0-5H20"></path></svg>
            <span class="tooltip">Chủ đề</span>
        </button>
        <button class="nav-btn" id="navBtnStats" data-view="stats" aria-label="Thống kê">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 3v18h18"></path><path d="m19 9-5 5-4-4-3 3"></path></svg>
            <span class="tooltip">Thống kê</span>
        </button>
        <button class="nav-btn" id="navBtnMethods" data-view="methods" aria-label="Kho Tri Thức">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15.042 21.672L13.684 16.6s.408-1.947 1.25-3.25c.842-1.303 2.002-2.5 3.5-3.5s3.25-1.25 3.25-1.25l5.072 1.358c.27.072.358.42.128.628l-3.35 3.35a.499.499 0 0 1-.594.052l-2.07-1.486c-.44-.314-.82-.53-1.11-.665-.29-.135-.55-.22-.78-.245s-.45.045-.63.155c-.18.11-.3.29-.36.5-.06.21.02.48.18.78.16.3.385.68.665 1.11l1.486 2.07a.499.499 0 0 1-.052.594l-3.35 3.35c-.208.23-.556.142-.628-.128z"/><path d="M12 15l-3-3 3-3 3 3-3 3z"/><path d="M9.01 11.99l-3.005 3.004a.997.997 0 0 1-1.41-1.41l3.004-3.005-3.004-3.005a.997.997 0 0 1 1.41-1.41l3.005 3.004z"/><path d="M5.01 11.99l-3.005 3.004a.997.997 0 0 1-1.41-1.41l3.004-3.005-3.004-3.005a.997.997 0 0 1 1.41-1.41l3.005 3.004z"/></svg>
            <span class="tooltip">Kho Tri Thức</span>
        </button>
        <button class="nav-btn" id="btnSettings" style="margin-top: auto;" aria-label="Cài đặt">
             <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 0 2l-.15.08a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.38a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1 0-2l.15.08a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"></path><circle cx="12" cy="12" r="3"></circle></svg>
            <span class="tooltip">Cài đặt</span>
        </button>
        <button class="nav-btn" id="navBtnGuide" data-view="guide" aria-label="Hướng dẫn">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 1 1 5.82 1c0 2-3 2-3 4"></path><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>
            <span class="tooltip">Hướng dẫn</span>
        </button>
    </nav>

    <main class="app-content">
      <header class="app-header panel-bg">
        <div class="row" style="gap:12px; align-items:center; flex:0 1 auto">
          <strong>📚 Pomodoro Study App</strong>
          <span class="badge" id="selectedContext">Chưa chọn Chủ đề con</span>
        </div>
        <div class="actions">
          <button class="btn ghost small" id="btnDashboard" title="Dashboard Tổng quan">📊 Tổng Quan </button>
          <a href="https://forms.gle/EfFqBJFTbFtDo5H4A" target="_blank" rel="noopener noreferrer" class="btn ghost small" title="Gửi phản hồi của bạn">💬 Phản Hồi</a>
          <button class="btn ghost small" id="btnExport" title="Xuất JSON">⬇️ Xuất File</button>
          <label class="btn ghost small" for="importFile" title="Nhập JSON">⬆️ Nhập File</label>
          <input type="file" id="importFile" accept="application/json" style="display:none" />
          <button class="btn small" id="btnToggleBg" title="Ẩn/Hiện giao diện">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/></svg>
          </button>
          <button class="btn small" id="btnFullscreen" title="Toàn màn hình">↗️</button>
        </div>
      </header>
      

      <div id="view-timer" class="view active">
        <section class="panel panel-bg">
          <div class="timer-header">
            <div id="welcomePanel" class="hidden panel-bg" style="text-align:center; padding: 20px; border-radius: var(--radius); width: 100%;">
                <h3>Chào mừng đến với Pomodoro Study App!</h3>
                <p>Hãy bắt đầu bằng cách chọn một <strong>Chủ đề con</strong> hoặc tạo Chủ đề/Chủ đề con mới.</p>
                <button class="btn acc" id="btnHelpCreateTopic">＋ Tạo Chủ đề Mới</button>
            </div>
            <div class="presets" role="group" aria-label="Chọn chế độ preset">
                <button id="btnPresetA" class="btn small ghost" data-preset="A"></button>
                <button id="btnPresetB" class="btn small ghost" data-preset="B"></button>
                <button id="btnPresetC" class="btn small ghost" data-preset="C">🌊 Flow</button>
            </div>
          </div>
          <hr />
          <div class="timer" aria-live="polite">
            <div class="badge" id="stateBadge">TRẠNG THÁI</div>
            
            <div class="timer-circle-container">
              <svg class="timer-svg" viewBox="0 0 100 100">
                  <circle class="timer-circle-bg" cx="50" cy="50" r="45"></circle>
                  <circle class="timer-circle-progress" cx="50" cy="50" r="45"></circle>
              </svg>
              <div id="timeDisplay" class="big-time">00:00</div>
            </div>

            <div class="tiny" id="cycleInfo"></div>

            <div class="tiny" id="breakSuggestionDisplay" style="min-height: 1.5em; font-style: italic; opacity: 0.8; transition: opacity 0.3s ease;"></div>

            <div id="windDownChecklist" class="hidden" style="text-align: left; max-width: 300px; margin: 0 auto; padding: 0 10px;">
              <h4 style="margin: 8px 0 4px; color: var(--acc); text-align: center;">Checklist Hạ nhiệt</h4>
              <ul style="list-style: '✓ '; margin: 0; padding-left: 20px; color: var(--sub);">
                <li>Lưu công việc đang làm (Save/Commit).</li>
                <li>Ghi chú nhanh "Next step".</li>
                <li>Dọn dẹp không gian làm việc.</li>
              </ul>
            </div>
            
            <div class="controls">
              <button class="btn acc" id="btnStart" aria-label="Bắt đầu (Space)">▶️ Bắt đầu</button>
              <button class="btn warn hidden" id="btnFinishFlow" aria-label="Kết thúc phiên làm việc">🧘 Bắt đầu nghỉ</button>
              <button class="btn" id="btnPause" aria-label="Tạm dừng (Space)">⏸️ Tạm dừng</button>
              <button class="btn" id="btnResume" aria-label="Tiếp tục (Space)">⏵ Tiếp tục</button>
              <button class="btn warn" id="btnSkip" aria-label="Bỏ qua (N)">⏭️ Bỏ qua</button>
              <button class="btn danger" id="btnReset">↺ Đặt lại</button>
              <button class="btn acc small hidden" id="btnBreakEarly">🧘 Nghỉ sớm</button>
            </div>
            <div class="tiny">Phím tắt: <strong>Space</strong> = Bắt đầu/Tạm dừng/Tiếp tục, <strong>N</strong> = Tiếp theo/Bỏ qua</div>
          </div>
        </section>

        <section class="panel panel-bg aux-panel">
            <nav class="tab-nav">
                <button class="tab-btn active" data-tab="tasks">Nhiệm vụ</button>
                <button class="tab-btn" data-tab="notes">Ghi chú</button>
                <button class="tab-btn" data-tab="ai">Gemini AI</button>
            </nav>
            <div id="tasks" class="tab-content active">
                <h4 style="margin: 0 0 8px; color: var(--sub);">To-do cho chủ đề con này:</h4>
                <ul id="subtopicTasksList" class="subtopic-todo-list"></ul>
                <div class="row" style="gap:8px; margin-top: 8px;">
                    <input type="text" id="newSubtopicTaskInput" placeholder="Thêm một task mới..." />
                    <button id="btnAddSubtopicTask" class="btn small" style="flex: 0 1 auto;">Thêm</button>
                </div>
            </div>
            <div id="notes" class="tab-content">
                <div id="generalNotesList" class="notes-list"></div>
                <div class="add-note-area" style="margin-top: 12px;">
                    <textarea id="newGeneralNoteText" placeholder="Thêm ghi chú mới..."></textarea>
                    <div style="text-align: right; margin-top: 8px;">
                        <button class="btn acc small" id="btnAddGeneralNote">＋ Thêm ghi chú</button>
                    </div>
                </div>
            </div>
            <div id="ai" class="tab-content">
                <div class="panel-header" style="margin-bottom: 8px; padding: 0;">
                    <h4 style="margin:0;">Gemini cho: <span id="currentSubtopicNameChat">(chưa chọn)</span></h4>
                    <div class="actions">
                        <button id="btnClearChat" class="btn small danger" title="Xóa lịch sử">🗑️</button>
                    </div>
                </div>
                <div id="chatMessages" class="chat-messages"></div>
                <div id="aiPromptSuggestions" style="display: flex; gap: 6px; margin: 8px 0; flex-wrap: wrap;">
                  <button class="btn small ghost" data-prompt="Giải thích khái niệm chính của chủ đề này">Giải thích khái niệm</button>
                  <button class="btn small ghost" data-prompt="Tạo một dàn ý chi tiết cho chủ đề này">Tạo dàn ý</button>
                  <button class="btn small ghost" data-prompt="Liệt kê 5 câu hỏi ôn tập quan trọng về chủ đề này">Tạo câu hỏi ôn tập</button>
                </div>
                <div class="chat-input-area">
                  <input type="text" id="chatInput" placeholder="Hỏi Gemini điều gì đó..." />
                  <button id="btnSendMessage" class="btn acc">Gửi</button>
                </div>
            </div>
        </section>
      </div>

      <div id="view-topics" class="view">
        <div class="panel panel-bg">
            <div class="row" style="gap:8px; align-items: center; margin-bottom: 12px;">
                <h3 style="margin: 0;">Quản lý Chủ đề</h3>
                <button class="btn small acc" id="btnAddTopic" style="margin-left: auto;">＋ Thêm Chủ đề</button>
            </div>
            <div id="topicsList"></div>
            <div class="footer-note">Nhấp mũi tên để mở/đóng danh sách chủ đề con.</div>
        </div>
      </div>
      
      <div id="view-stats" class="view">
      <script>
        window.addEventListener('DOMContentLoaded', () => {
          try {
            const topicsView = document.querySelector('#view-topics');
            if (!topicsView) return;
            const header = topicsView.querySelector('.row h3');
            if (header) header.textContent = 'Quản lý Chủ đề';
            const addBtn = topicsView.querySelector('#btnAddTopic');
            if (addBtn) addBtn.textContent = '+ Thêm Chủ đề';
            const note = topicsView.querySelector('.footer-note');
            if (note) note.textContent = 'Nhấp mũi tên để mở/đóng danh sách chủ đề con.';
          } catch (e) {}
        });
      </script>
        <section class="panel panel-bg">
            <h3 style="margin:0 0 12px 0;">Thống kê & Lịch sử — <span id="currentSubtopicName">(chưa chọn)</span></h3>
            <div class="stats-grid">
              <div class="stat-card"><h4>Tổng thời gian</h4><div class="stat-value" id="statTotal">0 phút</div></div>
              <div class="stat-card"><h4>Phiên</h4><div class="stat-value" id="statSessions">0</div></div>
              <div class="stat-card"><h4>Nhiệm vụ Hoàn thành</h4><div class="stat-value" id="statTasks">0</div></div>
            </div>
            <div style="margin-top:12px">
              <h4 style="margin:4px 0 8px; color:var(--sub)">Lịch sử (LÀM VIỆC)</h4>
              <div class="history" id="historyList"></div>
            </div>
        </section>
      </div>
      
      <div id="view-methods" class="view">
        <div class="panel panel-bg">
            <div class="row" style="gap:8px; align-items: center; margin-bottom: 12px;">
                <h3 style="margin:0;">💡 Kho Tri Thức Cá Nhân Hóa</h3>
                <button class="btn small acc" id="btnAddMethod" style="margin-left: auto;">＋ Thêm tri thức</button>
            </div>
            <p class="tiny" style="margin-top: -8px; margin-bottom: 20px;">Nhấp vào từng mục để xem chi tiết.</p>
            <div class="methods-container"></div>
        </div>
      </div>

      <div id="view-guide" class="view">
          <div class="panel panel-bg">
              <h3 style="margin-top: 0;">📖 Khám Phá Pomodoro Study App</h3>
              <p>
                  Chào mừng bạn đến với không gian học tập được thiết kế dành riêng cho sự tập trung và hiệu quả. Hãy cùng khám phá những tính năng sẽ đồng hành cùng bạn trên hành trình chinh phục tri thức.
              </p>

              <h4>🚀 Khởi Đầu Nhanh Chỉ Trong 4 Bước</h4>
              <p>Để hành trình của bạn luôn mạch lạc, mọi thứ trong ứng dụng được sắp xếp theo cấu trúc <strong>Chủ đề Lớn → Chủ đề con</strong>.</p>
              <ol>
                  <li>Mở mục <strong>📚 Chủ đề</strong> từ thanh điều hướng bên cạnh.</li>
                  <li>Nhấn <strong>＋ Thêm Chủ đề</strong> để tạo một lĩnh vực lớn (ví dụ: "Tiếng Anh Giao Tiếp").</li>
                  <li>Bên cạnh chủ đề vừa tạo, nhấn <strong>＋ Thêm</strong> để tạo một chủ đề con, chi tiết hơn (ví dụ: "Bài 1: Luyện phát âm IPA").</li>
                  <li>Chọn chủ đề con đó. Giờ đây, bạn đã sẵn sàng để bắt đầu phiên học đầu tiên của mình!</li>
              </ol>

              <hr />
              <h4>✨ Những Tính Năng Đáng Chú Ý</h4>

              <h4>Các Chế Độ Đồng Hồ Linh Hoạt ⏱️</h4>
              <p>Ứng dụng không chỉ có Pomodoro. Hãy chọn phương pháp phù hợp với công việc của bạn:</p>
              <ul>
                  <li><strong>Pomodoro Cổ Điển (Kiểu A/B):</strong> Làm việc tập trung trong các phiên định sẵn (ví dụ: 25 phút làm, 5 phút nghỉ) để xây dựng kỷ luật và nhịp độ.</li>
                  <li><strong>Chế độ Flowtime (Kiểu 🌊 Flow):</strong> Dành cho công việc cần dòng chảy sâu. Đồng hồ sẽ đếm lên, cho phép bạn làm việc đến khi tự cảm thấy cần nghỉ. Thời gian nghỉ sẽ được đề xuất dựa trên thời gian bạn đã làm việc.</li>
                  <li><strong>Đệm "Hạ nhiệt" (Wind-down):</strong> Một khoảng đệm tùy chỉnh giữa lúc làm và lúc nghỉ, giúp bạn kết thúc công việc đang dở, ghi chú lại "bước tiếp theo" và chuyển trạng thái một cách mượt mà, không bị cắt ngang đột ngột.</li>
              </ul> 
              <h4>Kho Tri Thức Theo Từng Chủ Đề Con 💡</h4>
<p>
    Mỗi một <strong>Chủ đề con</strong> giờ đây sẽ có một "Kho Tri Thức" hoàn toàn riêng biệt. Tính năng này cho phép bạn xây dựng một thư viện kiến thức chuyên sâu, chỉ liên quan đến lĩnh vực bạn đang học.
</p>
<p>
    Ví dụ, các ghi chú và phương pháp học "Tiếng Anh Giao Tiếp" sẽ chỉ xuất hiện khi bạn chọn chủ đề con đó, và sẽ không bị lẫn với các công thức trong chủ đề con "Giải tích Toán học".
</p>
<p>
    Với trình soạn thảo mạnh mẽ, bạn vẫn có thể dễ dàng định dạng tiêu đề, in đậm, tạo danh sách và làm nổi bật những thông tin quan trọng nhất cho từng môn học của mình.
</p>

              <h4>Quản Lý Chủ Đề Trực Quan</h4>
              <p>Dễ dàng sắp xếp các mục tiêu học tập của bạn. Sử dụng thao tác <strong>kéo và thả</strong> để sắp xếp lại thứ tự các Chủ đề hoặc di chuyển một Chủ đề con sang một lĩnh vực khác một cách trực quan.</p>

              <h4>Nhiệm Vụ & Ghi Chú Tích Hợp 📝</h4>
              <p>Ngay trong màn hình đồng hồ, bạn có thể tạo danh sách việc cần làm (to-do) cho từng chủ đề con hoặc ghi lại những ý tưởng chợt nảy ra mà không làm gián đoạn dòng chảy công việc.</p>

              <h4>Chế Độ Zen 🧘</h4>
              <p>Khi cần tập trung tuyệt đối, hãy nhấn vào biểu tượng con mắt (👁️). Giao diện sẽ ẩn đi, chỉ để lại hình nền và chiếc đồng hồ. Trong chế độ này, bạn có thể <strong>kéo thả đồng hồ</strong> đến bất kỳ vị trí nào trên màn hình để có một không gian làm việc gọn gàng nhất.</p>

              <h4>Thống Kê & Cột Mốc 🏆</h4>
              <p>Theo dõi hành trình của bạn qua những con số biết nói. Ứng dụng sẽ tự động ghi nhận và chúc mừng khi bạn đạt được những cột mốc quan trọng về thời gian tập trung, biến mỗi nỗ lực thành một thành tựu đáng tự hào.</p>

              <hr />
              <h4>⌨️ Phím Tắt Thông Minh</h4>
              <ul>
                  <li><kbd>Space</kbd>: Bắt đầu / Tạm dừng / Tiếp tục phiên học.</li>
                  <li><kbd>N</kbd>: Bỏ qua phiên làm việc hoặc nghỉ hiện tại.</li>
                  <li><kbd>Esc</kbd>: Đóng các cửa sổ đang mở (như Cài đặt).</li>
              </ul>

              <hr />
              <h4>🛠️ Cài Đặt Nâng Cao & Tích Hợp</h4>

              <h4>Trợ Lý Gemini AI 🧠</h4>
              <p>Biến ứng dụng thành một người bạn đồng hành thông minh. Ngoài việc hỏi đáp, bạn còn có thể:</p>
              <ul>
                  <li><strong>Tự động Định dạng Thông minh:</strong> Khi soạn thảo trong mục "Phương pháp", hãy để AI tự động phân tích và định dạng văn bản thô của bạn—tự nhận diện tiêu đề, các ý chính cần in đậm và danh sách.</li>
                  <li><strong>Thiết lập:</strong> Truy cập Google AI Studio để tạo API Key miễn phí và dán vào ô "Gemini API Key" trong Cài đặt của ứng dụng.</li>
              </ul>

              <h4>Tùy Biến Giao Diện & Âm Thanh 🎨</h4>
              <p>Biến không gian học tập thành của riêng bạn:</p>
              <ul>
                  <li><strong>Nhiều Theme & Hình nền:</strong> Lựa chọn giữa các theme có sẵn (Sáng, Tối, Pastel...) hoặc <strong>tải lên hình nền của riêng bạn</strong> để tạo cảm hứng.</li>
                  <li><strong>Âm báo Tùy chỉnh:</strong> Bạn có thể <strong>tải lên các file âm thanh (.mp3, .wav...) của riêng mình</strong> để sử dụng làm chuông báo cho các phiên làm việc và nghỉ ngơi.</li>
              </ul>

              <h4>Nhạc Nền YouTube 🎶</h4>
              <p>Tạo không gian học tập hoàn hảo bằng cách phát một video hoặc danh sách phát YouTube làm nhạc nền. Dán đường dẫn (URL) vào ô "Nhạc nền YouTube" trong Cài đặt.</p>

              <h4>An Toàn Dữ Liệu: Sao Lưu & Phục Hồi 🛡️</h4>
              <p>Ứng dụng tự động sao lưu tiến trình của bạn mỗi ngày. Bạn có thể tùy chỉnh số ngày lưu giữ bản sao lưu và phục hồi dữ liệu từ một ngày trong quá khứ nếu cần. ⚠️ <strong>Cảnh báo:</strong> Phục hồi sẽ ghi đè toàn bộ dữ liệu hiện tại.</p>
          </div>
      </div>
    </main>
  </div>

  <div class="modal" id="modalMilestone" role="dialog" aria-modal="true" aria-labelledby="milestoneTitle">
    <div class="modal-card" style="width: min(600px, 94vw);">
        <h3 id="milestoneTitle">🎉 Chúc mừng Bạn!</h3>
        <p id="milestoneMessage" style="white-space: pre-wrap; line-height: 1.6;"></p>
        <div class="row" style="justify-content:flex-end; margin-top:12px">
            <button class="btn acc" id="btnMilestoneClose">Tiếp tục hành trình!</button>
        </div>
    </div>
  </div>
  <div class="modal" id="modalSettings" role="dialog" aria-modal="true" aria-labelledby="settingsTitle">
      <div class="modal-card">
          <h3 id="settingsTitle">⚙️ Cài đặt</h3>
          <nav class="tab-nav">
              <button class="tab-btn active" data-tab="settings-timer">Đồng hồ</button>
              <button class="tab-btn" data-tab="settings-ui">Giao diện & Âm thanh</button>
              <button class="tab-btn" data-tab="settings-integrations">Tích hợp</button>
          </nav>
          <div class="settings-content">
              <div id="settings-timer" class="tab-content active" style="flex-direction:column; gap:20px;">
                  <div class="row" id="timerPresetSelector" style="margin-bottom:16px;">
                      <button class="btn acc" data-preset-target="A"> Kiểu A </button>
                      <button class="btn ghost" data-preset-target="B"> Kiểu B </button>
                      <button class="btn ghost" data-preset-target="C"> Kiểu C (Flow) </button>
                  </div>
                  <div id="settings-pomodoro">
                      <h4>Thời lượng Pomodoro</h4>
                      <div class="row">
                          <label>LÀM VIỆC (phút)<input type="number" id="set_work" min="1" /></label>
                          <label>HẠ NHIỆT (phút)<input type="number" id="set_winddown" min="0" /></label>
                          <label>NGHỈ NGẮN (phút)<input type="number" id="set_short" min="1" /></label>
                          <label>NGHỈ DÀI (phút)<input type="number" id="set_long" min="1" /></label>
                      </div>
                      <div class="row">
                          <label>Chu kỳ Pomodoro<input type="number" id="set_cycles" min="1" /></label>
                          <label>Chu kỳ nghỉ dài<input type="number" id="set_interval" min="2" /></label>
                      </div>
                  </div>
                  <div id="settings-flowtime" class="hidden">
                      <h4>Flowtime</h4>
                      <div class="row">
                          <label>Tỷ lệ nghỉ (Làm việc / X)
                              <input type="number" id="set_flowRatio" min="1" max="20" />
                          </label>
                      </div>
                      <p class="tiny" style="margin-top: 4px;">Gợi ý: Thời gian nghỉ = tổng thời gian làm việc / X. Mặc định là 5.</p>
                  </div>
                  <div class="settings-row-toggle">
                          <label for="set_autoStartNext">Tự động bắt đầu phiên tiếp theo</label>
                          <label class="toggle-switch">
                              <input type="checkbox" id="set_autoStartNext">
                              <span class="slider"></span>
                          </label>
                      </div>
                  <div class="settings-row-toggle">
                          <label for="set_enableWinddown">Bật Hạ nhiệt sau phiên làm</label>
                          <label class="toggle-switch">
                              <input type="checkbox" id="set_enableWinddown">
                              <span class="slider"></span>
                          </label>
                      </div>
                  <div class="settings-row-toggle">
                          <label for="set_enableSessionNotes">Nhắc ghi chú sau mỗi phiên</label>
                          <label class="toggle-switch">
                              <input type="checkbox" id="set_enableSessionNotes">
                              <span class="slider"></span>
                          </label>
                      </div>
              </div>
              <div id="settings-ui" class="tab-content" style="flex-direction: column; gap: 20px;">
                  <div class="row" style="margin-top: 12px; align-items: center; gap: 12px;">
                      <label data-i18n-key="settingsLanguage">Ngôn ngữ</label>
                      <select id="set_language" style="min-width: 180px;">
                          <option value="vi" data-i18n-key="languageVi">Tiếng Việt</option>
                          <option value="en" data-i18n-key="languageEn">English</option>
                      </select>
                  </div>
                  <div>
                      <h4>Giao diện</h4>
                      <div class="row">
                          <label>Theme Giao Diện
                                <select id="set_theme_color">
                                    <option value="default">Mặc định (Dark Blue)</option>
                                    <option value="light">Light - Trà Sữa</option>
                                    <option value="pastel">Pastel - Dễ thương</option>
                                    <option value="lofi">Lofi Study Room</option>
                                    <option value="space">Space Station</option>
                                </select>
                          </label>
                      </div>
                      <div class="row" style="margin-top: 12px;">
                          <label>Chế độ hiển thị nền
                              <select id="set_backgroundMode">
                                  <option value="cover">Lấp đầy (Mặc định)</option>
                                  <option value="contain">Vừa vặn (Sắc nét)</option>
                                  <option value="auto">Kích thước gốc (Lặp lại)</option>
                              </select>
                          </label>
                      </div>
                      <div class="row" style="margin-top: 12px;">
                          <label style="flex: 1;">Hình nền</label>
                          <div style="flex: 2; display: flex; gap: 8px;">
                              <label class="btn small ghost" for="uploadBg" style="flex: 1;">Tải ảnh mới</label>
                              <input type="file" id="uploadBg" accept="image/*" class="hidden" />
                              <button class="btn small danger" id="btnClearBg" style="flex: 1;">Xóa nền</button>
                          </div>
                      </div>
                      <div class="row">
                          <label style="flex: 1;">Độ trong suốt của nền</label>
                          <input type="range" id="set_panelOpacity" min="0.1" max="1" step="0.05" style="flex: 2;">
                      </div>
                      
                      
                   </div>
                  
                   <div>
                      <h4>Âm thanh</h4>
                      
                      <div class="row">
                          <label style="flex: 1;">Âm lượng (0–1)
                              <input type="number" id="set_volume" step="0.05" min="0" max="1"/>
                          </label>
                          <button class="btn" id="btnTestSound" style="flex-grow: 0; align-self: flex-end;">Test</button>
                      </div>

                      <div class="row" style="margin-top: 12px;">
                          <label style="flex: 1;">Kiểu âm báo (Mặc định)
                              <select id="set_theme">
                                  <option value="beep">Beep</option>
                                  <option value="chime">Chime</option>
                              </select>
                          </label>
                      </div>

                      <div class="settings-row-toggle" style="margin-top: 16px;">
                          <label for="set_useCustomSounds">Sử dụng âm báo tùy chỉnh</label>
                          <label class="toggle-switch">
                              <input type="checkbox" id="set_useCustomSounds">
                              <span class="slider"></span>
                          </label>
                      </div>

                      <div id="customSoundsContainer" class="hidden">
                          
                          <div class="row custom-sound-row">
                              <label for="uploadSoundWork" class="custom-sound-label">Âm báo hết LÀM VIỆC</label>
                              <label class="btn small ghost" for="uploadSoundWork" title="Tải lên tệp âm báo LÀM VIỆC">Tải lên</label>
                              <input type="file" id="uploadSoundWork" accept="audio/*" class="hidden" />
                          </div>
                          
                          <div class="row custom-sound-row">
                              <label for="uploadSoundBreak" class="custom-sound-label">Âm báo hết NGHỈ NGẮN</label>
                              <label class="btn small ghost" for="uploadSoundBreak" title="Tải lên tệp âm báo NGHỈ NGẮN">Tải lên</label>
                              <input type="file" id="uploadSoundBreak" accept="audio/*" class="hidden" />
                          </div>
                          
                          <div class="row custom-sound-row">
                              <label for="uploadSoundLong" class="custom-sound-label">Âm báo hết NGHỈ DÀI</label>
                              <label class="btn small ghost" for="uploadSoundLong" title="Tải lên tệp âm báo NGHỈ DÀI">Tải lên</label>
                              <input type="file" id="uploadSoundLong" accept="audio/*" class="hidden" />
                          </div>

                      </div>
                  </div>
              </div>
              <div id="settings-integrations" class="tab-content" style="flex-direction: column; gap: 20px;">
                  <div>
                      <h4>Tích hợp AI</h4>
                      <label>Gemini API Key
                          <input type="password" id="set_apiKey" placeholder="Dán API Key của bạn vào đây..." />
                      </label>
                      <div class="tiny">Cần có để sử dụng các tính năng AI. Lấy key miễn phí tại <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener noreferrer">Google AI Studio</a>.</div>
                  </div>
                  <div>
                      <h4>🎵 Nhạc nền YouTube</h4>
                      <div class="row" style="gap:8px; align-items:center;">
                          <input type="text" id="set_youtubeUrl" placeholder="Dán link YouTube vào đây..." style="flex:1;">
                          </div>
                      <div id="ytUrlFeedback" class="tiny" style="min-height: 1.2em; padding: 4px 0;"></div>
                      <div class="row" style="margin-top: 4px;">
                          <label style="flex: 0 1 auto; display: flex; align-items: center; gap: 8px; font-size: 14px;">
                              <input type="checkbox" id="set_ytThumbAsBg">
                              <span>Dùng ảnh bìa video làm nền</span>
                          </label>
                      </div>
                      <div class="row" style="margin-top: 8px;">
                          <button id="btnToggleYtSound" class="btn small" style="flex:0 1 auto;" title="Dừng sẽ không tự phát lại cho đến khi bạn bấm ▶️">▶️</button>
                          <input type="range" id="ytSoundVolume" min="0" max="100" step="1" value="80" style="flex:1;">
                      </div>
                      <div class="tiny" style="text-align:center; margin-top:4px;">Âm lượng</div>
                  </div>
                  <div>
                      <h4>🛡️ Cài đặt sao lưu</h4>
                      <div class="row">
                          <label>Số ngày sao lưu cần giữ lại
                               <input type="number" id="set_backupDays" min="1" max="30" />
                          </label>
                      </div>
                  </div>
                  <div>
                      <h4>🛡️ Phục hồi dữ liệu</h4>
                      <p class="tiny">Phục hồi dữ liệu từ một bản sao lưu tự động hàng ngày. Hành động này sẽ ghi đè lên dữ liệu hiện tại của bạn.</p>
                      <div class="row">
                          <select id="backupList" style="flex: 3;"></select>
                          <button id="btnRestoreBackup" class="btn warn small" style="flex: 1;">Phục hồi</button>
                      </div>
                  </div>
              </div>
          </div>
          <div class="row" style="margin-top:16px; justify-content:flex-end">
              <button class="btn ghost" id="btnDefaults">Mặc định</button>
              <button class="btn acc" id="btnSaveSettings">Lưu</button>
              <button class="btn" id="btnCloseSettings">Đóng</button>
          </div>
      </div>
  </div>

  <div class="modal" id="modalNote" role="dialog" aria-modal="true" aria-labelledby="noteTitle">
    <div class="modal-card">
      <h3 id="noteTitle">📝 Ghi chú cho phiên vừa hoàn thành</h3>
      <div class="row"><textarea id="noteText" placeholder="Bạn học được gì? Khó khăn? Next steps?"></textarea></div>
      <div class="row" style="justify-content:flex-end; margin-top:8px; gap: 12px;">
        <button class="btn" id="btnSummarizeNote">✨ Tóm tắt & Gợi ý</button>
        <button class="btn" id="btnSkipNote">Bỏ qua</button>
        <button class="btn acc" id="btnSaveNote">Lưu ghi chú</button>
      </div>
    </div>
  </div>

  <div class="modal" id="modalGeneric" role="dialog" aria-modal="true" aria-labelledby="genericTitle">
      <div class="modal-card" style="width: min(450px, 94vw);">
          <h3 id="genericTitle">Tiêu đề</h3>
          <p id="genericMessage" class="hidden"></p>
          <input type="text" id="genericInput" class="hidden" />
          <div class="row" style="justify-content:flex-end; margin-top:12px">
              <button class="btn" id="btnGenericCancel">Hủy</button>
              <button class="btn acc" id="btnGenericOk">OK</button>
          </div>
      </div>
  </div>
  
  <div class="modal" id="modalDashboard" role="dialog" aria-modal="true" aria-labelledby="dashboardTitle">
    <div class="modal-card" style="width: min(800px, 95vw);">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <h3 id="dashboardTitle">📊 Tổng quan</h3>
            <button class="btn ghost small" id="btnCloseDashboard">Đóng</button>
        </div>
        <p class="tiny">Tổng hợp thời gian và số phiên đã hoàn thành trên tất cả các chủ đề.</p>
        <div id="dashboardContent" style="max-height: 60vh; overflow-y: auto;"></div>
    </div>
  </div>

  <div class="modal" id="modalMethodEditor" role="dialog" aria-modal="true">
    <div class="modal-card" style="width: min(800px, 95vw);">
      <h3 id="methodEditorTitle">Chỉnh-sửa Phương-pháp</h3>
      
      <div style="display: flex; flex-direction: column; gap: 12px; margin-top: 12px;">
        <input type="hidden" id="methodEditorId">
        <label>Tiêu-đề<input type="text" id="methodEditorTitleInput"></label>
        
        <label>Nội-dung</label>
        <div class="editor-toolbar">
          <button id="toolH4" class="btn small ghost" title="Tiêu-đề nhỏ">H</button>
          <button id="toolBold" class="btn small ghost" title="In đậm">B</button>
          <button id="toolItalic" class="btn small ghost" title="In nghiêng">I</button>
          <button id="toolList" class="btn small ghost" title="Danh-sách">1.</button>
          <button id="toolBullet" class="btn small ghost" title="Danh sách chấm tròn">•</button>

          <div class="color-picker-wrapper">
            <button id="toolColor" class="btn small ghost" title="Màu chữ">A</button>
            <div class="color-palette hidden">
              <button class="color-swatch" style="background-color: var(--text);" data-color="var(--text)" title="Màu chữ mặc định"></button>
              <button class="color-swatch" style="background-color: var(--acc);" data-color="var(--acc)" title="Màu nhấn mạnh"></button>
              <button class="color-swatch" style="background-color: var(--acc-2);" data-color="var(--acc-2)" title="Màu tích cực"></button>
              <button class="color-swatch" style="background-color: var(--warn);" data-color="var(--warn)" title="Màu cảnh báo"></button>
              <button class="color-swatch" style="background-color: var(--danger);" data-color="var(--danger)" title="Màu nguy hiểm"></button>
              <button class="color-swatch" style="background-color: var(--purple);" data-color="var(--purple)" title="Màu tím"></button>
            </div>
          </div>
        </div>

        <div class="editor-container">
            <div id="methodEditorContentInput" class="editable-content" contenteditable="true"></div>
        </div>

      </div>

      <div class="row" style="justify-content:space-between; margin-top:16px">
        <button id="btnAutoFormat" class="btn small" disabled title="Tính năng này yêu cầu Gemini API Key">✨ Tự động định dạng</button>
        <div>
          <button class="btn" id="btnCancelMethodEditor">Hủy</button>
          <button class="btn acc" id="btnSaveMethod">Lưu</button>
        </div>
      </div>
    </div>
  </div>

  <div class="toasts" id="toasts"></div>
  <audio id="audioWorkEnd"></audio>
  <audio id="audioBreakEnd"></audio>
  <audio id="audioLongEnd"></audio>
  <div id="youtube-player-container"></div>

  <div id="draggableTimer" class="draggable-timer">00:00</div>

  <div id="soundPermissionBar" class="sound-permission-bar" role="alert" aria-live="polite">
    <span class="msg">Nhấn "Bật âm thanh" để cho phép phát nhạc nền.</span>
    <button id="btnEnableSound" class="btn small acc">Bật âm thanh</button>
  </div>
<!-- YouTube Iframe API is loaded dynamically when needed -->
<!-- === START: Inline Minimal Sortable (Offline-Safe) === -->
<script>
// Minimal Sortable shim for offline single-file usage.
// Supports: draggable selector, cross-list via same group, onEnd callback.
(function(){
  if (window.Sortable) return; // Respect existing if loaded
  const DND = { src: null, from: null, selector: null, group: null };
  function makeDraggable(container, selector){
    Array.from(container.querySelectorAll(selector)).forEach(el => {
      try { el.setAttribute('draggable','true'); } catch(_) {}
    });
  }
  function closestItem(e, selector){
    const t = e.target && e.target.closest ? e.target.closest(selector) : null;
    return t || null;
  }
  function Sortable(container, opts){
    this.el = container;
    this.options = opts || {};
    const selector = this.options.draggable || '*';
    const group = this.options.group || null;
    makeDraggable(container, selector);
    const handleDragStart = (e) => {
      const item = closestItem(e, selector);
      if (!item) return;
      DND.src = item; DND.from = container; DND.selector = selector; DND.group = group;
      e.dataTransfer.effectAllowed = 'move';
      try { e.dataTransfer.setData('text/plain', ''); } catch(_) {}
    };
    const handleDragOver = (e) => {
      if (!DND.src) return;
      // Only allow drop if same selector and group matches (or no group)
      const sameGroup = (!group && !DND.group) || (group && DND.group && group === DND.group);
      if (!sameGroup) return;
      const target = closestItem(e, selector);
      if (!target) return;
      e.preventDefault();
    };
    const handleDrop = (e) => {
      if (!DND.src) return;
      const sameGroup = (!group && !DND.group) || (group && DND.group && group === DND.group);
      if (!sameGroup) return;
      const target = closestItem(e, selector);
      if (!target) return;
      e.preventDefault();
      const from = DND.from;
      const to = container;
      const children = Array.from(from.querySelectorAll(DND.selector));
      const oldIndex = children.indexOf(DND.src);
      if (target && DND.src && target !== DND.src) {
        to.insertBefore(DND.src, target);
      }
      const newChildren = Array.from(to.querySelectorAll(DND.selector));
      const newIndex = newChildren.indexOf(DND.src);
      if (typeof this.options.onEnd === 'function') {
        try { this.options.onEnd({ oldIndex, newIndex, from, to, item: DND.src }); } catch(_) {}
      }
      DND.src = null; DND.from = null; DND.selector = null; DND.group = null;
    };
    this._listeners = { handleDragStart, handleDragOver, handleDrop };
    container.addEventListener('dragstart', handleDragStart);
    container.addEventListener('dragover', handleDragOver);
    container.addEventListener('drop', handleDrop);
    this.destroy = () => {
      container.removeEventListener('dragstart', handleDragStart);
      container.removeEventListener('dragover', handleDragOver);
      container.removeEventListener('drop', handleDrop);
    };
  }
  window.Sortable = Sortable;
})();
</script>
<!-- === END: Inline Minimal Sortable === -->
  <script>
    // Đã bỏ fixVietnameseUI: dùng trực tiếp tiếng Việt (UTF-8) trong HTML/JS
    // Nút toàn màn hình: dùng biểu tượng ↗️/↙️ thay vì chữ
    window.addEventListener('load', ()=>{ try { updateFullscreenButton(); } catch(_) {} });
    const IS_FILE_PROTOCOL = (window.location.protocol === 'file:');
    // Watchdog: thông báo nếu API YouTube tải chậm hoặc thất bại
    function startYtApiWatchdog(){
      const fb = document.getElementById('ytUrlFeedback');
      if (!fb) return;
      const t1 = setTimeout(()=>{
        try{ if (!window.YT || !window.YT.Player){ fb.textContent='Đang tải API YouTube...'; fb.style.color='var(--sub)'; } }catch(_){ }
      }, 1500);
      const t2 = setTimeout(()=>{
        try{ if (!window.YT || !window.YT.Player){ fb.textContent='Không tải được API YouTube. Kiểm tra mạng hoặc tải lại trang.'; fb.style.color='var(--danger)'; } }catch(_){ }
      }, 7000);
      window.__ytApiWatchdog = { cancel(){ clearTimeout(t1); clearTimeout(t2);} };
    }
    // Watchdog is triggered when API loading is requested
    // Inline i18n fallback so app works over file:// without CORS
    (function(){
      const DICT = {
        'timer.cycleInfo': ({ current = 0, target = 0 } = {}) => `Chu kỳ ${current}/${target}`,
        'timer.selectSubtopicPrompt': 'Vui lòng chọn một Chủ đề con trước khi thực hiện thao tác.'
      };
      window.t = function t(key, vars){
        try {
          const v = DICT[key];
          if (typeof v === 'function') return v(vars || {});
          if (typeof v === 'string') return v;
        } catch(_) {}
        return key;
      };
      window.loadLanguage = function loadLanguage(lang){
        try { localStorage.setItem('lang', lang || 'vi'); } catch(_) {}
        return Promise.resolve();
      };
    })();
    // === i18n core: translations + applyLanguage + t() + loadLanguage ===
    let currentLang = 'vi';
    const translations = {
      vi: {
        navTooltipTimer: "Đồng hồ",
        navTooltipTopics: "Chủ đề",
        navTooltipStats: "Thống kê",
        navTooltipKnowledge: "Kho Tri Thức",
        navTooltipSettings: "Cài đặt",
        navTooltipGuide: "Hướng dẫn",
        headerDashboard: "📊 Tổng Quan",
        headerFeedback: "💬 Phản Hồi",
        selectedContextNone: "Chưa chọn Chủ đề con",
        welcomeHeading: "Chào mừng đến với Pomodoro Study App!",
        welcomeText: "Hãy bắt đầu bằng cách chọn một Chủ đề con hoặc tạo Chủ đề/Chủ đề con mới.",
        btnHelpCreateTopic: "+ Tạo Chủ đề Mới",
        presetsAria: "Chọn chế độ preset",
        btnPresetCText: "🧘 Flow",
        settingsTitle: "⚙️ Cài đặt",
        settingsTabTimer: "Đồng hồ",
        settingsTabUI: "Giao diện & Âm thanh",
        settingsTabIntegrations: "Tích hợp",
        settingsLanguage: "Ngôn ngữ",
        languageVi: "Tiếng Việt",
        languageEn: "English",
        btnSaveSettings: "Lưu",
        btnClose: "Đóng",
        btnExport: "📤 Xuất File",
        btnImport: "📥 Nhập File",
        titleToggleUI: "Ẩn/Hiện giao diện",
        titleFullscreen: "Toàn màn hình",
        tasksTab: "Nhiệm vụ",
        notesTab: "Ghi chú",
        aiTab: "Gemini AI",
        todoHeading: "To-do cho chủ đề con này:",
        newTaskPlaceholder: "Thêm một task mới...",
        btnAddTask: "Thêm",
        stateBadgeReady: "SẴN SÀNG",
        stateBadgeFocus: "LÀM VIỆC",
        stateBadgeFocusFlow: "LÀM VIỆC (FLOW)",
        stateBadgeShortBreak: "NGHỈ NGẮN",
        stateBadgeLongBreak: "NGHỈ DÀI",
        stateBadgeWindDown: "HẠ NHIỆT",
        stateBadgePaused: "TẠM DỪNG",
        btnStart: "▶️ Bắt đầu",
        btnFinishFlow: "🧘 Bắt đầu nghỉ",
        btnPause: "⏸️ Tạm dừng",
        btnResume: "▶️ Tiếp tục",
        btnSkip: "⏭️ Bỏ qua",
        btnReset: "↺ Đặt lại",
        btnBreakEarly: "⏱️ Nghỉ sớm",
        shortcutsLabel: "Phím tắt: Space = Bắt đầu/Tạm dừng/Tiếp tục, N = Tiếp theo/Bỏ qua",
        windDownTitle: "Checklist Hạ nhiệt",
        windDownSave: "Lưu công việc đang làm (Save/Commit).",
        windDownNext: "Ghi chú nhanh \"Next step\".",
        windDownClean: "Dọn dẹp không gian làm việc.",
        'error.saveData': ({message='' }={})=>`Lỗi lưu dữ liệu: ${message}`,
        'session.completed': 'Phiên đã hoàn thành! Nhấn Bắt đầu để bắt đầu phiên tiếp theo.',
        'session.windDownStart': 'Đến giờ hạ nhiệt. Hãy kết thúc công việc và chuẩn bị nghỉ ngơi.',
        'flowtime.rest': ({minutes=0, ratio=5}={})=>`Nghỉ ${minutes} phút theo Flowtime (${ratio}).`,
        'session.longBreakStart': 'Tuyệt vời! Đã đến lúc nghỉ dài.',
        'notes.summaryCleared': 'Đã xóa tóm tắt.',
        'error.cannotSaveChanges': 'Không thể lưu thay đổi.',
        'notes.noNotesToSummarize': 'Chưa có ghi chú để tóm tắt.',
        'notes.summarizeFailed': 'Tóm tắt thất bại.',
        'settings.restoredDefaults': 'Đã khôi phục mặc định',
        'settings.saved': 'Đã lưu cài đặt',
        'error.fileSave': 'Lỗi lưu file.',
        'notes.enterBeforeSummarize': 'Vui lòng nhập ghi chú trước khi tóm tắt.',
        'chat.cleared': 'Đã xóa lịch sử chat.',
        'audio.enabled': 'Âm thanh đã được bật!',
        'yt.invalidLink': 'Chưa có link hợp lệ. Dán link rồi bấm ▶️.',
        'yt.playing': 'Đang phát nhạc nền...',
        'yt.stopped': 'Đã dừng nhạc nền.',
        'import.success': 'Đã nhập dữ liệu thành công!',
        'import.failed': ({message='' }={})=>`Nhập thất bại: ${message}`,
        'backup.selectOne': 'Vui lòng chọn một bản sao lưu.',
        'backup.restoreSuccess': 'Phục hồi dữ liệu thành công! Tải lại trang...',
        'backup.error': ({message='' }={})=>`Lỗi: ${message}`,
        'yt.thumbDisabledLightTheme': 'Đã tắt nền YouTube để hợp với theme sáng.',
        'notes.saved': 'Đã lưu ghi chú',
        'ai.formatNeedContent': 'Cần có nội dung để AI định dạng.',
        'ai.formatted': 'AI đã định dạng xong!',
        'ai.formatFailed': 'AI không thể định dạng lúc này.',
        'preset.switched': ({newPreset='' }={})=>`Đã chuyển sang Kiểu ${newPreset}.`,
        'bg.updated': 'Đã cập nhật hình nền.',
        'bg.cleared': 'Đã xóa hình nền tùy chỉnh.',
        'sound.savedWorkEnd': 'Đã lưu âm báo hết LÀM VIỆC.',
        'sound.savedShortEnd': 'Đã lưu âm báo hết NGHỈ NGẮN.',
        'sound.savedLongEnd': 'Đã lưu âm báo hết NGHỈ DÀI.',
        'error.fullscreen': ({message='' }={})=>`Lỗi: Không thể bật chế độ toàn màn hình: ${message}`,
        'error.init': ({message='' }={})=>`Lỗi khởi tạo: ${message}`,
        'ai.needApiKey': 'Vui lòng nhập Gemini API Key trong phần Cài đặt.',
        'error.networkGemini': 'Lỗi mạng khi kết nối đến Gemini. Vui lòng kiểm tra kết nối internet.',
        'timer.cycleInfo': ({ current = 0, target = 0 } = {}) => `Chu kỳ ${current}/${target}`,
        'timer.selectSubtopicPrompt': 'Vui lòng chọn một Chủ đề con trước khi thực hiện thao tác.',
      },
      en: {
        navTooltipTimer: "Timer",
        navTooltipTopics: "Topics",
        navTooltipStats: "Stats",
        navTooltipKnowledge: "Knowledge Base",
        navTooltipSettings: "Settings",
        navTooltipGuide: "Guide",
        headerDashboard: "📊 Dashboard",
        headerFeedback: "💬 Feedback",
        selectedContextNone: "No Subtopic Selected",
        welcomeHeading: "Welcome to the Pomodoro Study App!",
        welcomeText: "Start by selecting a Subtopic or create a new Topic/Subtopic.",
        btnHelpCreateTopic: "+ Create New Topic",
        presetsAria: "Select preset mode",
        btnPresetCText: "🧘 Flow",
        settingsTitle: "⚙️ Settings",
        settingsTabTimer: "Timer",
        settingsTabUI: "Interface & Sound",
        settingsTabIntegrations: "Integrations",
        settingsLanguage: "Language",
        languageVi: "Vietnamese",
        languageEn: "English",
        btnSaveSettings: "Save",
        btnClose: "Close",
        btnExport: "📤 Export File",
        btnImport: "📥 Import File",
        titleToggleUI: "Toggle UI",
        titleFullscreen: "Fullscreen",
        tasksTab: "Tasks",
        notesTab: "Notes",
        aiTab: "Gemini AI",
        todoHeading: "To-do for this subtopic:",
        newTaskPlaceholder: "Add a new task...",
        btnAddTask: "Add",
        stateBadgeReady: "READY",
        stateBadgeFocus: "FOCUS",
        stateBadgeFocusFlow: "FOCUS (FLOW)",
        stateBadgeShortBreak: "SHORT BREAK",
        stateBadgeLongBreak: "LONG BREAK",
        stateBadgeWindDown: "WIND DOWN",
        stateBadgePaused: "PAUSED",
        btnStart: "▶️ Start",
        btnFinishFlow: "🧘 Start Break",
        btnPause: "⏸️ Pause",
        btnResume: "▶️ Resume",
        btnSkip: "⏭️ Skip",
        btnReset: "↺ Reset",
        btnBreakEarly: "⏱️ Break Early",
        shortcutsLabel: "Shortcuts: Space = Start/Pause/Resume, N = Next/Skip",
        windDownTitle: "Wind Down Checklist",
        windDownSave: "Save your work (Save/Commit).",
        windDownNext: "Jot a quick \"Next step\".",
        windDownClean: "Clear your workspace.",
        'error.saveData': ({message='' }={})=>`Error saving data: ${message}`,
        'session.completed': 'Session complete! Press Start to begin the next one.',
        'session.windDownStart': 'Time to wind down. Wrap up and get ready to rest.',
        'flowtime.rest': ({minutes=0, ratio=5}={})=>`Rest ${minutes} minutes via Flowtime (${ratio}).`,
        'session.longBreakStart': "Great! It's time for a long break.",
        'notes.summaryCleared': 'Summary cleared.',
        'error.cannotSaveChanges': 'Unable to save changes.',
        'notes.noNotesToSummarize': 'No notes to summarize yet.',
        'notes.summarizeFailed': 'Summarization failed.',
        'settings.restoredDefaults': 'Defaults restored',
        'settings.saved': 'Settings saved',
        'error.fileSave': 'File save error.',
        'notes.enterBeforeSummarize': 'Please enter a note before summarizing.',
        'chat.cleared': 'Chat history cleared.',
        'audio.enabled': 'Audio is now enabled!',
        'yt.invalidLink': 'No valid link yet. Paste the link and press ▶️.',
        'yt.playing': 'Playing background music...',
        'yt.stopped': 'Background music stopped.',
        'import.success': 'Data imported successfully!',
        'import.failed': ({message='' }={})=>`Import failed: ${message}`,
        'backup.selectOne': 'Please select a backup.',
        'backup.restoreSuccess': 'Data restored! Reloading page...',
        'backup.error': ({message='' }={})=>`Error: ${message}`,
        'yt.thumbDisabledLightTheme': 'Disabled YouTube thumbnail background for light theme.',
        'notes.saved': 'Note saved',
        'ai.formatNeedContent': 'Content is required for AI formatting.',
        'ai.formatted': 'AI finished formatting!',
        'ai.formatFailed': 'AI cannot format right now.',
        'preset.switched': ({newPreset='' }={})=>`Switched to Preset ${newPreset}.`,
        'bg.updated': 'Background updated.',
        'bg.cleared': 'Custom background cleared.',
        'sound.savedWorkEnd': 'Saved alert for FOCUS end.',
        'sound.savedShortEnd': 'Saved alert for SHORT BREAK end.',
        'sound.savedLongEnd': 'Saved alert for LONG BREAK end.',
        'error.fullscreen': ({message='' }={})=>`Error: Unable to enter fullscreen: ${message}`,
        'error.init': ({message='' }={})=>`Initialization error: ${message}`,
        'ai.needApiKey': 'Please enter a Gemini API Key in Settings.',
        'error.networkGemini': 'Network error connecting to Gemini. Please check your internet.',
        'timer.cycleInfo': ({ current = 0, target = 0 } = {}) => `Cycle ${current}/${target}`,
        'timer.selectSubtopicPrompt': 'Please select a Subtopic first.',
      }
    };
    function setElTextPreserveIcon(el, text) {
      const icon = el.querySelector('svg, strong, span.badge');
      if (icon && (el.tagName === 'BUTTON' || el.tagName === 'A' || el.classList.contains('tooltip'))) {
        el.innerHTML = icon.outerHTML + ' ' + text;
      } else {
        el.textContent = text;
      }
    }
    function applyLanguage(lang) {
      currentLang = (lang === 'en' ? 'en' : 'vi');
      const dict = translations[currentLang];
      try { document.documentElement.setAttribute('lang', currentLang); } catch(_) {}
      document.querySelectorAll('[data-i18n-key]').forEach(el => {
        const key = el.getAttribute('data-i18n-key');
        const value = dict[key];
        if (value == null) return;
        const attrsRaw = el.getAttribute('data-i18n-attr') || '';
        const attrs = attrsRaw.split('|').map(s => s.trim()).filter(Boolean);
        const attrOnly = attrs.includes('only');
        attrs
          .filter(attr => attr && attr !== 'only')
          .forEach(attr => {
            el.setAttribute(attr, typeof value === 'function' ? value() : value);
          });
        if (!attrOnly) {
          const text = typeof value === 'function' ? value() : value;
          setElTextPreserveIcon(el, text);
        }
      });
    }
    window.t = function t(key, vars) {
      try {
        const v = translations[currentLang]?.[key];
        if (typeof v === 'function') return v(vars || {});
        if (typeof v === 'string') return v;
      } catch(_) {}
      return key;
    };
    window.loadLanguage = function loadLanguage(lang) {
      const next = (lang === 'en' ? 'en' : 'vi');
      try { localStorage.setItem('lang', next); } catch(_) {}
      applyLanguage(next);
      return Promise.resolve();
    };
    // Tag key elements with data-i18n-key at runtime (non-intrusive to HTML structure)
    function tagI18nElements(){
      const setKey = (sel, key) => { const el = document.querySelector(sel); if (el) el.setAttribute('data-i18n-key', key); };
      const setKeyAttr = (sel, key, attr) => { const el = document.querySelector(sel); if (el) { el.setAttribute('data-i18n-key', key); el.setAttribute('data-i18n-attr', attr); } };
      // Nav tooltips
      setKey('#navBtnTimer .tooltip', 'navTooltipTimer');
      setKey('#navBtnTopics .tooltip', 'navTooltipTopics');
      setKey('#navBtnStats .tooltip', 'navTooltipStats');
      setKey('#navBtnMethods .tooltip', 'navTooltipKnowledge');
      setKey('#btnSettings .tooltip', 'navTooltipSettings');
      setKey('#navBtnGuide .tooltip', 'navTooltipGuide');
      // Header
      setKey('#selectedContext', 'selectedContextNone');
      setKeyAttr('#btnDashboard', 'headerDashboard', 'title');
      setKeyAttr('a.btn.ghost.small[rel~="noopener"]', 'headerFeedback', 'title');
      setKey('#btnExport', 'btnExport');
      const importLbl = document.querySelector('label.btn.ghost.small[for="importFile"]'); if (importLbl) importLbl.setAttribute('data-i18n-key','btnImport');
      setKeyAttr('#btnToggleBg', 'titleToggleUI', 'title');
      setKeyAttr('#btnFullscreen', 'titleFullscreen', 'title');
      // Welcome & presets
      setKey('#welcomePanel h3', 'welcomeHeading');
      setKey('#welcomePanel p', 'welcomeText');
      setKey('#btnHelpCreateTopic', 'btnHelpCreateTopic');
      const presets = document.querySelector('.presets[role="group"]'); if (presets){ presets.setAttribute('data-i18n-key','presetsAria'); presets.setAttribute('data-i18n-attr','aria-label|only'); }
      setKey('#btnPresetC', 'btnPresetCText');
      // Timer badge + controls
      setKey('#stateBadge', 'stateBadgeReady');
      setKey('#btnStart', 'btnStart');
      setKey('#btnFinishFlow', 'btnFinishFlow');
      setKey('#btnPause', 'btnPause');
      setKey('#btnResume', 'btnResume');
      setKey('#btnSkip', 'btnSkip');
      setKey('#btnReset', 'btnReset');
      setKey('#btnBreakEarly', 'btnBreakEarly');
      // Wind down checklist
      setKey('#windDownChecklist h4', 'windDownTitle');
      const wd1 = document.querySelector('#windDownChecklist li:nth-child(1)'); if (wd1) wd1.setAttribute('data-i18n-key','windDownSave');
      const wd2 = document.querySelector('#windDownChecklist li:nth-child(2)'); if (wd2) wd2.setAttribute('data-i18n-key','windDownNext');
      const wd3 = document.querySelector('#windDownChecklist li:nth-child(3)'); if (wd3) wd3.setAttribute('data-i18n-key','windDownClean');
      // Tabs & tasks
      setKey('.tab-nav .tab-btn[data-tab="tasks"]', 'tasksTab');
      setKey('.tab-nav .tab-btn[data-tab="notes"]', 'notesTab');
      setKey('.tab-nav .tab-btn[data-tab="ai"]', 'aiTab');
      setKey('#tasks h4', 'todoHeading');
      const newTask = document.querySelector('#newSubtopicTaskInput'); if (newTask){ newTask.setAttribute('data-i18n-key','newTaskPlaceholder'); newTask.setAttribute('data-i18n-attr','placeholder'); }
      setKey('#btnAddSubtopicTask', 'btnAddTask');
      // Settings modal
      setKey('#settingsTitle', 'settingsTitle');
      setKey('.tab-btn[data-tab="settings-timer"]', 'settingsTabTimer');
      setKey('.tab-btn[data-tab="settings-ui"]', 'settingsTabUI');
      setKey('.tab-btn[data-tab="settings-integrations"]', 'settingsTabIntegrations');
      setKey('#btnSaveSettings', 'btnSaveSettings');
      setKey('#btnCloseSettings', 'btnClose');
    }
    function ensureYouTubeAPI(){
      if (IS_FILE_PROTOCOL) return Promise.resolve(false);
      try { if (window.YT && window.YT.Player) return Promise.resolve(true); } catch(_) {}
      if (window.__ytApiPromise) return window.__ytApiPromise;
      startYtApiWatchdog();
      window.__ytApiPromise = new Promise((resolve, reject) => {
        try {
          const s = document.createElement('script');
          s.src = 'https://www.youtube.com/iframe_api';
          s.async = true; s.defer = true;
          s.onload = () => resolve(true);
          s.onerror = () => reject(new Error('Failed to load YouTube API'));
          document.head.appendChild(s);
        } catch(err) { reject(err); }
      });
      return window.__ytApiPromise;
    }

    // storageManager will manage persistence
    // =============================
    // STORAGE MANAGER - Quản lý Dữ liệu và Sao lưu
    // =============================
    const storageManager = {
        DB_NAME: 'PomodoroAppDB',
        DB_VERSION: 1,
        db: null,
        async initDB() {
            return new Promise((resolve, reject) => {
                if (this.db) return resolve(this.db);
                const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('settings')) {
                        db.createObjectStore('settings');
                    }
                    if (!db.objectStoreNames.contains('topics')) {
                        db.createObjectStore('topics', { keyPath: 'id' });
                    }
                    if (!db.objectStoreNames.contains('subtopics')) {
                        const subtopicsStore = db.createObjectStore('subtopics', { keyPath: 'id' });
                        subtopicsStore.createIndex('by_topic', 'topicId');
                    }
                    if (!db.objectStoreNames.contains('backups')) {
                        db.createObjectStore('backups', { keyPath: 'date' });
                    }
                };
                request.onsuccess = (event) => {
                    this.db = event.target.result;
                    console.log('IndexedDB initialized successfully.');
                    resolve(this.db);
                };
                request.onerror = (event) => {
                    console.error('IndexedDB error:', event.target.errorCode);
                    reject(event.target.error);
                };
            });
        },
        async _getStore(storeName, mode = 'readonly') {
            await this.initDB();
            const tx = this.db.transaction([storeName], mode);
            return tx.objectStore(storeName);
        },
        async getSettings() {
            const store = await this._getStore('settings');
            return new Promise((resolve, reject) => {
                const request = store.get('main_settings');
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        },
        async updateSettings(settingsObject) {
            const store = await this._getStore('settings', 'readwrite');
            return new Promise((resolve, reject) => {
                const request = store.put(settingsObject, 'main_settings');
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        },
        async getAll(storeName) {
            const store = await this._getStore(storeName);
            return new Promise((resolve, reject) => {
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        },
        async update(storeName, object) {
            const store = await this._getStore(storeName, 'readwrite');
            return new Promise((resolve, reject) => {
                const request = store.put(object);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        },
        async add(storeName, object) {
            const store = await this._getStore(storeName, 'readwrite');
            return new Promise((resolve, reject) => {
                const request = store.add(object);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        },
        async delete(storeName, key) {
            const store = await this._getStore(storeName, 'readwrite');
            return new Promise((resolve, reject) => {
                const request = store.delete(key);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        },
        async save(data) {
            await this.initDB();
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction(['settings', 'topics', 'subtopics'], 'readwrite');
                const settingsStore = tx.objectStore('settings');
                const topicsStore = tx.objectStore('topics');
                const subtopicsStore = tx.objectStore('subtopics');

                settingsStore.put(data.settings, 'main_settings');
                topicsStore.clear();
                subtopicsStore.clear();

                data.topics.forEach(topic => {
                    const { subtopics, ...topicData } = topic;
                    topicsStore.put(topicData);
                    (subtopics || []).forEach(sub => subtopicsStore.put(sub));
                });

                tx.oncomplete = () => resolve();
                tx.onerror = e => reject(e.target.error);
            });
        },
        async autoBackup(data) {
            await this.initDB();
            const today = new Date().toISOString().slice(0, 10);
            const lastBackupDate = localStorage.getItem('lastBackupDate');
            if (today !== lastBackupDate) {
                console.log(`Creating backup for ${today}...`);
                const backupData = { date: today, data: JSON.parse(JSON.stringify(data)) };
                const transaction = this.db.transaction(['backups'], 'readwrite');
                const store = transaction.objectStore('backups');
                const request = store.put(backupData);
                request.onsuccess = () => {
                    localStorage.setItem('lastBackupDate', today);
                    console.log('Daily backup successful.');
                    this.cleanupOldBackups((data?.settings?.backupDaysToKeep) || 7);
                };
                request.onerror = (event) => {
                    console.error('Backup failed:', event.target.error);
                };
            }
        },
        async cleanupOldBackups(daysToKeep) {
            await this.initDB();
            const transaction = this.db.transaction(['backups'], 'readwrite');
            const store = transaction.objectStore('backups');
            const request = store.getAllKeys();
            request.onsuccess = () => {
                const allKeys = request.result.sort().reverse();
                if (allKeys.length > daysToKeep) {
                    const keysToDelete = allKeys.slice(daysToKeep);
                    keysToDelete.forEach(key => {
                        store.delete(key);
                        console.log(`Deleted old backup: ${key}`);
                    });
                }
            };
        },
        async getBackupList() {
            await this.initDB();
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction(['backups'], 'readonly');
                const store = transaction.objectStore('backups');
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result.sort((a, b) => b.date.localeCompare(a.date)));
                request.onerror = (event) => reject(event.target.error);
            });
        },
        async restoreBackup(date) {
            await this.initDB();
            return new Promise((resolve, reject) => {
                const transaction = this.db.transaction(['backups'], 'readonly');
                const store = transaction.objectStore('backups');
                const request = store.get(date);
                request.onsuccess = () => {
                    if (request.result && request.result.data) {
                        localStorage.setItem('pomodoroData_v11', JSON.stringify(request.result.data));
                        resolve(request.result.data);
                    } else {
                        reject(new Error('Không tìm thấy bản sao lưu.'));
                    }
                };
                request.onerror = (event) => reject(event.target.error);
            });
        },
        exportData(data) {
            // Sanitize sensitive fields before export (do not leak API keys)
            let safe = {};
            try { safe = JSON.parse(JSON.stringify(data || {})); } catch(_) { safe = data; }
            try { if (safe && safe.settings) safe.settings.apiKey = ''; } catch(_) {}
            const blob = new Blob([JSON.stringify(safe, null, 2)], { type: 'application/json' });
            const a = document.createElement('a');
            const ts = new Date();
            const pad = n => `${n}`.padStart(2, '0');
            a.href = URL.createObjectURL(blob);
            a.download = `pomodoro_backup_${ts.getFullYear()}${pad(ts.getMonth() + 1)}${pad(ts.getDate())}.json`;
            a.click();
            URL.revokeObjectURL(a.href);
        },
        async importData(file) {
            const text = await file.text();
            const obj = JSON.parse(text);
            if (!obj.version || !obj.settings || !Array.isArray(obj.topics)) {
                throw new Error('Tệp không đúng định dạng');
            }
            // Preserve existing apiKey if absent or empty in import
            try {
                const currentKey = (window.data && window.data.settings && window.data.settings.apiKey) || '';
                if (!('apiKey' in obj.settings) || obj.settings.apiKey === '') {
                    obj.settings.apiKey = currentKey;
                }
            } catch(_) {}
            localStorage.setItem('pomodoroData_v11', JSON.stringify(obj));
            return obj;
        }
    };

    // =============================
    // Helpers
    // =============================
    const $ = (sel, root=document) => root.querySelector(sel);
    
    // Danh sách gợi ý cho giờ nghỉ (break)
    const breakSuggestions = [
      "Hãy đứng dậy vươn vai và duỗi người.",
      "Uống một ly nước để giữ đủ nước.",
      "Nhìn ra xa qua cửa sổ trong 20 giây.",
      "Đi dạo một vòng ngắn quanh phòng.",
      "Thực hiện vài động tác hít thở sâu.",
      "Sắp xếp lại không gian làm việc của bạn.",
      "Nghe một bản nhạc yêu thích.",
      "Nhắm mắt và thư giãn trong một phút.",
      "Lắc nhẹ cổ tay và vai trong 30 giây.",
      "Thả lỏng toàn thân, cảm nhận hơi thở.",
      "Đặt tay lên ngực, cảm nhận nhịp tim của mình.",
      "Mở cửa sổ cho không khí mới vào phòng.",
      "Massage nhẹ hai bên thái dương.",
      "Xem một tấm ảnh dễ thương hoặc làm bạn vui.",
      "Đếm ngược từ 20 đến 0 thật chậm rãi.",
      "Tự hỏi bản thân: “Mình cảm thấy thế nào lúc này?”",
      "Kiểm tra và chỉnh lại tư thế ngồi cho đúng.",
      "Nhẹ nhàng nhắm mắt và mỉm cười với chính mình.",
      "Thả lỏng hai chân, lắc nhẹ cổ chân dưới bàn.",
      "Chú ý đến cảm giác nhiệt độ, ánh sáng trong phòng.",
      "Đếm chậm từng nhịp thở đến số 10.",
      "Làm động tác “thở dài” sâu một lần, thả lỏng vai.",
      "Lắng nghe hơi thở ra vào qua mũi.",
      "Nhớ uống một ngụm nước nhé!",
      "Đứng lên và đi lại vài bước để máu lưu thông.",
      "Chớp mắt liên tục 10 lần để tránh khô mắt.",
      "Rửa mặt hoặc vỗ nhẹ lên mặt để tỉnh táo hơn.",
      "Nắn nhẹ các khớp ngón tay sau khi gõ phím.",
      "Nạp năng lượng bằng một món ăn nhẹ lành mạnh.",
      "Bước ra ban công, tận hưởng ánh sáng tự nhiên.",
      "Kiểm tra nhịp thở – nếu gấp gáp, hãy làm chậm lại.",
      "Tự nhắc: Nghỉ ngơi đúng cách là để làm việc tốt hơn!"
    ];
    const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
    function on(el, evt, handler){ if(!el){ console.warn('Missing element', evt); return; } el.addEventListener(evt, handler); }
    const formatMMSS = (s) => { const m = Math.floor(s/60).toString().padStart(2,'0'); const ss = Math.floor(s%60).toString().padStart(2,'0'); return `${m}:${ss}`; };
    const uid = (p='id') => `${p}_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;

    // === START: A11y Focus Trap (non-invasive) ===
    let __releaseFocusTrap = null;
    function trapFocus(modalEl){
      try {
        const focusable = modalEl.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
        if (!focusable.length) return;
        const first = focusable[0];
        const last = focusable[focusable.length - 1];
        const handler = (e) => {
          if (e.key === 'Tab') {
            if (e.shiftKey && document.activeElement === first) { e.preventDefault(); last.focus(); }
            else if (!e.shiftKey && document.activeElement === last) { e.preventDefault(); first.focus(); }
          }
        };
        modalEl.addEventListener('keydown', handler);
        first.focus();
        __releaseFocusTrap = () => { try { modalEl.removeEventListener('keydown', handler); } catch(_){} };
      } catch(_) {}
    }
    function releaseFocus(){ if (__releaseFocusTrap) { try { __releaseFocusTrap(); } catch(_){} __releaseFocusTrap = null; } }
    // === END: A11y Focus Trap ===

    

    
    const todayISO = () => new Date().toISOString();
    function toast(msg, ms=2600){ const box=$('#toasts'); const t=document.createElement('div'); t.className='toast'; t.textContent=msg; box.appendChild(t); setTimeout(()=>{t.style.opacity='0';}, ms-300); setTimeout(()=> box.removeChild(t), ms); }
    function escapeHTML(str){ return str.replace(/[&<>"']/g, m => ({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;' }[m])); }
    function formatDaysHoursMinutes(totalMinutes) {
        if (!totalMinutes || totalMinutes < 1) return "0 phút";
        const totalHours = Math.floor(totalMinutes / 60);
        const minutes = totalMinutes % 60;
        const mm = minutes.toString().padStart(2, '0');
        return `${totalHours} tiếng ${mm} phút`;
    }
    function formatGeminiResponse(text) {
        return text.replace(/(\*\*|__|\*|_|#+\s*)/g, '');
    }
    // Parse a minimal Markdown-like syntax to safe HTML for Methods
    function parseSimpleMarkdown(text) {
        const lines = (text || '').split('\n');
        let html = '';
        let listType = null; // 'ol' | 'ul'
        const closeList = () => { if (listType) { html += (listType === 'ol' ? '</ol>' : '</ul>'); listType = null; } };
        for (let raw of lines) {
            let line = (raw || '').trim();
            if (!line) { closeList(); continue; }
            if (line.startsWith('#### ')) {
                closeList();
                html += `<h4>${escapeHTML(line.substring(5))}</h4>`;
            } else if (/^\d+\.\s/.test(line)) {
                if (listType !== 'ol') { closeList(); html += '<ol>'; listType = 'ol'; }
                const itemText = line.substring(line.indexOf(' ') + 1);
                html += `<li>${escapeHTML(itemText)}</li>`;
            } else if (line.startsWith('- ')) {
                if (listType !== 'ul') { closeList(); html += '<ul>'; listType = 'ul'; }
                html += `<li>${escapeHTML(line.substring(2))}</li>`;
            } else {
                closeList();
                line = escapeHTML(line)
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/_(.*?)_/g, '<i>$1</i>');
                html += `<p>${line}</p>`;
            }
        }
        closeList();
        return html;
    }
    function wrapTextInMarkdown(textarea, prefix, suffix = '') {
        if (!textarea) return;
        const start = textarea.selectionStart || 0;
        const end = textarea.selectionEnd || 0;
        const selectedText = textarea.value.substring(start, end);
        const newText = prefix + selectedText + (suffix || prefix);
        textarea.setRangeText(newText, start, end, 'end');
        textarea.focus();
    }
    function updateEditorPreview() {
        const contentInput = $('#methodEditorContentInput');
        const preview = $('#editorPreview');
        if (!contentInput || !preview) return;
        const markdownText = contentInput.value || '';
        preview.innerHTML = parseSimpleMarkdown(markdownText);
    }
    function normalizeDataStructure(obj){
        if (!obj || typeof obj !== 'object') return;
        const s = obj.settings || {};
        const mergedSettings = {
            ...defaults.settings,
            ...s,
            durations: { ...defaults.settings.durations, ...(s.durations || {}) }
        };
        if (!Array.isArray(mergedSettings.achievedMilestones)) mergedSettings.achievedMilestones = [];
        if (typeof mergedSettings.useCustomSounds !== 'boolean') mergedSettings.useCustomSounds = false;
        obj.settings = mergedSettings;
        obj.topics = Array.isArray(obj.topics) ? obj.topics : [];
        obj.topics.forEach(t => {
            t.subtopics = Array.isArray(t.subtopics) ? t.subtopics : [];
            t.subtopics.forEach(st => {
                st.tasks = st.tasks || [];
                st.generalNotes = st.generalNotes || [];
                st.summaries = st.summaries || [];
                st.chatHistory = st.chatHistory || [];
                // Ensure each subtopic has its own knowledge base
                st.methods = Array.isArray(st.methods) ? st.methods : [];
                st.stats = st.stats || { totalMinutes: 0, sessionsCompleted: 0, tasksCompleted: 0 };
                st.sessions = st.sessions || [];
                st.timerState = st.timerState || { state: 'idle', prevState: null, remaining: 0, segmentTotal: 0, cycleIndex: 0 };
            });
        });
    }
    function extractYouTubeID(url) {
        if (!url) return null;
        const regExp = /^.*(?:youtu.be\/|shorts\/|live\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([A-Za-z0-9_-]{11}).*/;
        const match = url.match(regExp);
        return match ? match[1] : null;
    }
    let sessionYoutubeUrl = '';
    function getActiveYoutubeUrl(){
        try {
            if (sessionYoutubeUrl) return sessionYoutubeUrl;
            const el = document.getElementById('set_youtubeUrl');
            const v = (el && el.value ? el.value : '').trim();
            return v;
        } catch(_) { return ''; }
    }
    function getActiveVideoId(){ return extractYouTubeID(getActiveYoutubeUrl()); }
    function handleYoutubeUrlInput() {
        const input = $("#set_youtubeUrl");
        const feedbackEl = $("#ytUrlFeedback");
        const toggleBtn = $("#btnToggleYtSound");
        const url = input.value.trim();
        const videoId = extractYouTubeID(url);

        if (videoId) {
            feedbackEl.textContent = "OK. Link hợp lệ. Đang chuẩn bị phát...";
            feedbackEl.style.color = 'var(--acc-2)';
            toggleBtn.disabled = false;
            sessionYoutubeUrl = url;
            // Khi dán link mới, coi như ý định phát nhạc → bỏ trạng thái tạm dừng thủ công
            try { ytUserPaused = false; } catch(_) {}
            try {
                const thumbUrl = `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`;
                const img = new Image();
                img.onload = async () => { data.settings.customBg = thumbUrl; try { await saveData(); } catch(_) {} applyCustomBg(); };
                img.onerror = async () => { const fb = `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`; data.settings.customBg = fb; try { await saveData(); } catch(_) {} applyCustomBg(); };
                img.src = thumbUrl;
            } catch(_) {}
            try {
                if (IS_FILE_PROTOCOL) {
                    const isMuted = _ytUnlocked ? 0 : 1;
                    fallbackLoadVideo(videoId, { autoplay: 1, mute: isMuted });
                    try { setTimeout(() => { try { fallbackPostMessage('playVideo'); } catch(_) {} }, 250); } catch(_) {}
                    if (!_ytUnlocked) { showSoundPermission(); }
                try { setTimeout(() => { const fb = document.getElementById('ytUrlFeedback'); if (fb) fb.textContent = 'Đang phát'; }, 500); } catch(_) {}
                } else {
                    ensureYouTubeAPI().then(() => {
                        updateYouTubePlayer();
                        try {
                            if (_ytUnlocked) {
                                ytFadeInPlay();
                            } else if (ytPlayer && ytPlayer.mute && ytPlayer.playVideo) {
                                // Prime muted playback like 4.html and show permission bar
                                ytPlayer.mute();
                                ytPlayer.playVideo();
                                _ytPrimed = true;
                                showSoundPermission();
                            }
                        } catch(_) {}
                    }).catch(()=>{});
                }
            } catch(_) {}
        } else if (url === '') {
            feedbackEl.textContent = "";
            toggleBtn.disabled = true;
            if (IS_FILE_PROTOCOL) { try { fallbackStop(); } catch(_) {} }
            else if (ytPlayer && ytPlayer.stopVideo) { ytPlayer.stopVideo(); }
        } else {
            feedbackEl.textContent = "❌ Link không hợp lệ hoặc không được hỗ trợ.";
            feedbackEl.style.color = 'var(--danger)';
            toggleBtn.disabled = true;
        }
    }
    
    // THAY ĐỔI: Hàm applyTheme được cập nhật hoàn toàn
    function applyTheme(previewTheme) {
        const theme = previewTheme || data.settings.theme || 'default';
        document.body.dataset.theme = theme;
        
        const themeHasBg = ['lofi', 'space'].includes(theme);
        const isLightTheme = (theme === 'light' || theme === 'pastel');
        const customBg = data.settings.customBg;

        // helper: always clear any previously forced inline fallback
        const clearInlineBgFallback = () => { try { document.body.style.backgroundImage = ''; } catch(_) {} };

        if (customBg && !data.settings.useYtThumbnailAsBg) {
            document.body.style.setProperty('--bg-image', `url(${customBg})`);
            clearInlineBgFallback();
        } else if (customBg && data.settings.useYtThumbnailAsBg) {
            document.body.style.setProperty('--bg-image', `url(${customBg})`);
            clearInlineBgFallback();
        } else if (themeHasBg) {
            // Use theme-provided background (e.g., lofi/space)
            document.body.style.removeProperty('--bg-image');
            clearInlineBgFallback();
        } else if (isLightTheme) {
            // For light/pastel, avoid dark radial fallback
            document.body.style.setProperty('--bg-image', 'none');
            clearInlineBgFallback();
        } else {
            // Dark/default fallback
            document.body.style.setProperty('--bg-image', '');
            document.body.style.backgroundImage = 'radial-gradient(1200px 800px at 10% -10%, #20285b 0%, #0f1222 50%, #0b0e1a 100%)';
        }
    }


    const defaults = {
        version: 1,
        settings: {
            apiKey: "",
            currentView: 'timer',
            preset: 'A',
            autoStartNext: true,
            soundOn: true,
            volume: 0.8,
            soundTheme: 'beep',
            theme: 'default',
            cyclesA: 4,
            longBreakIntervalA: 4,
            cyclesB: 4,
            longBreakIntervalB: 4,
            // Flowtime preset (Preset C)
            flowtimeBreakRatio: 5,
            // Bật/tắt Hạ nhiệt sau phiên làm
            enableWinddown: true,
            // Bật/tắt nhắc ghi chú sau mỗi phiên
            enableSessionNotes: true,
            durations: { A_work: 25, A_short: 5, A_long: 15, A_winddown: 2, B_work: 50, B_short: 10, B_long: 30, B_winddown: 5 },
            selectedTopicId: '',
            selectedSubtopicId: '',
            collapsedTopics: {},
            customBg: '',
            useCustomSounds: false,
            customSounds: { work_end: '', break_end: '', long_end: '' },
            youtubeUrl: '',
            youtubeVolume: 80,
            useYtThumbnailAsBg: true,
            panelOpacity: 0.85,
            panelBlur: 10,
            backgroundMode: 'cover',
            backupDaysToKeep: 7,
            achievedMilestones: [],
            // Seeded learning methods as HTML content (Rich Text)
            methods: [
                {
                    id: uid('m'),
                    title: 'Kỹ Thuật Feynman: Hiểu Sâu Bằng Cách Giải Thích Đơn Giản',
                    content: `<p>Nguyên tắc cốt lõi của kỹ thuật này dựa trên một ý tưởng duy nhất: "Nếu bạn không thể giải thích một chủ đề một cách đơn giản, bạn chưa thực sự hiểu nó." Mục tiêu là biến kiến thức phức tạp thành lời giải thích đơn giản đến mức một đứa trẻ cũng có thể hiểu.</p><h4>Quy Trình 4 Bước Tinh Gọn</h4><ol><li><strong>Học:</strong> Chọn một chủ đề và viết ra tất cả những gì bạn biết về nó.</li><li><strong>Dạy:</strong> Giả vờ dạy lại chủ đề này bằng ngôn ngữ đơn giản nhất có thể. Viết hoặc nói to ra.</li><li><strong>Tìm & Sửa Lỗi:</strong> Bất cứ khi nào bạn bị "kẹt", phải dùng thuật ngữ phức tạp, hoặc không thể giải thích trôi chảy, bạn đã tìm thấy lỗ hổng kiến thức của mình. Hãy quay lại tài liệu gốc để học lại cho đến khi lấp được lỗ hổng đó.</li><li><strong>Đơn Giản Hóa:</strong> Sắp xếp lại lời giải thích cuối cùng, sử dụng các ví dụ hoặc phép ví von đơn giản để nó trở nên mạch lạc và dễ hiểu nhất.</li></ol><h4>Cốt Lõi</h4><p>Kỹ thuật Feynman buộc bạn phải chuyển từ việc tiếp thu thụ động (đọc, nghe) sang chủ động xử lý thông tin. Quá trình "bị kẹt" khi giải thích chính là công cụ chẩn đoán mạnh mẽ nhất, nó chỉ ra chính xác điểm bạn còn yếu.</p><p><i>Cách nhanh nhất để kiểm tra và củng cố sự hiểu biết của bạn là thử dạy lại nó cho người khác một cách đơn giản.</i></p>`
                },
                {
                    id: uid('m'),
                    title: 'Phương Pháp Viết của Benjamin Franklin: Học Viết Bằng Cách Tái Tạo',
                    content: `<p>Benjamin Franklin đã tự rèn luyện kỹ năng viết từ kém cỏi trở nên bậc thầy bằng một phương pháp chủ động, thay vì chỉ đọc một cách thụ động. Cốt lõi của phương pháp này là phân tích, tái tạo, và so sánh với một bài viết chất lượng cao.</p><p>Đây là một ví dụ kinh điển của "Luyện tập có Chủ đích": tập trung vào điểm yếu, có mục tiêu rõ ràng và nhận phản hồi ngay lập tức.</p><h4>Quy Trình 3 Bước Cốt Lõi</h4><ol><li><strong>Phân Tích (Deconstruct):</strong> Đọc một bài viết mẫu xuất sắc. Sau đó, chỉ ghi lại những ý chính của từng đoạn hoặc từng câu ra một tờ giấy riêng.</li><li><strong>Tái Tạo (Reconstruct):</strong> Vài ngày sau, khi đã quên đi văn phong của bản gốc, hãy dùng những ghi chú ý chính đó để viết lại toàn bộ bài viết bằng ngôn ngữ và cách diễn đạt của chính bạn.</li><li><strong>So Sánh & Sửa Lỗi (Compare & Correct):</strong> Đối chiếu trực tiếp bài viết của bạn với bản gốc. Đây là bước quan trọng nhất. Nó giúp bạn phát hiện ngay lập tức những lỗi sai về từ vựng, cấu trúc câu, và cách sắp xếp ý tưởng để sửa chữa.</li></ol><p>Franklin còn thực hành các biến thể nâng cao như xáo trộn thứ tự các ý chính để rèn luyện tư duy logic, hoặc chuyển văn xuôi thành thơ để làm giàu vốn từ.</p><h4>Nguyên Tắc Vàng</h4><p>Thành công của phương pháp này không đến từ việc lặp lại vô thức, mà đến từ vòng lặp phản hồi trực tiếp. Việc so sánh với bản gốc buộc bạn phải đối mặt và sửa chữa những điểm yếu cụ thể của mình, biến việc học từ một quá trình mơ hồ thành một bài tập có thể đo lường được.</p><p><i>Để viết giỏi hơn, đừng chỉ đọc. Hãy chọn một bài viết hay, phân tích nó, cố gắng viết lại, và so sánh để tìm ra lỗi sai.</i></p>`
                },
                {
                    id: uid('m'),
                    title: 'Nguyên Tắc 80/20 Để Chinh Phục Lĩnh Vực Mới',
                    content: `<p>Để không bị choáng ngợp khi học một lĩnh vực mới, hãy tập trung vào 20% kiến thức cốt lõi mang lại 80% kết quả (Liều lượng Hiệu quả Tối thiểu).</p><h4>20% cốt lõi: Áp dụng Khung Phân tích 5 Bước để xác định 20% quan trọng nhất:</h4><ol><li><strong>Xác định Kết quả:</strong> Mục tiêu cuối cùng của bạn là gì? (ví dụ: xây dựng được một trang web).</li><li><strong>Phân tích Nền tảng:</strong> Tìm 3-5 nguyên lý bất biến của ngành.</li><li><strong>Nhận diện Lỗi sai Phổ biến:</strong> Học cách tránh những lỗi mà người mới hay mắc phải.</li><li><strong>Tìm "Yếu tố Nhân":</strong> Kỹ năng nào sẽ giúp học mọi thứ khác dễ dàng hơn? (ví dụ: nhạc lý trong âm nhạc).</li><li><strong>Lập bản đồ Ứng dụng Thực tiễn:</strong> Tập trung vào 20% công việc chiếm 80% thời gian thực tế của ngành.</li></ol>`
                },
                {
                    id: uid('m'),
                    title: 'Gợi Nhớ Chủ Động (Active Recall): Nguyên Tắc Cốt Lõi Để Học Sâu',
                    content: `<p>Gợi nhớ chủ động là hành động nỗ lực truy xuất thông tin từ não bộ mà không nhìn vào tài liệu. Đây là phương pháp học hiệu quả vượt trội so với việc đọc lại, highlight hay tóm tắt một cách thụ động.</p><h4>Nguyên Tắc 20/80</h4><p><strong>20% Cốt lõi:</strong> Hành động "vắt óc" để nhớ lại thông tin sẽ củng cố các liên kết thần kinh, giúp chuyển kiến thức vào bộ nhớ dài hạn. Cảm giác khó khăn khi cố gắng nhớ chính là dấu hiệu của việc học tập hiệu quả đang diễn ra.</p><p><strong>80% Kết quả:</strong> Bạn sẽ ghi nhớ kiến thức sâu và lâu hơn, đồng thời biết chính xác mình đang yếu ở đâu.</p><h4>Các Phương Pháp Quan Trọng Nhất</h4><ul><li><strong>Tự Kiểm Tra (Self-testing):</strong> Thay vì đọc lại ghi chú, hãy che chúng đi và tự đặt câu hỏi cho mình. Ví dụ: Dùng flashcards (thẻ ghi nhớ) và luôn trả lời trước khi lật xem đáp án.</li><li><strong>Kỹ thuật "Blurting":</strong> Sau khi học một chủ đề, hãy đóng sách lại và viết ra giấy mọi thứ bạn có thể nhớ. Sau đó, so sánh với tài liệu gốc để lấp đầy những lỗ hổng kiến thức.</li><li><strong>Dạy lại cho người khác:</strong> Giải thích một khái niệm cho người khác buộc bạn phải truy xuất, đơn giản hóa và sắp xếp lại thông tin một cách mạch lạc.</li></ul><p><i>Tóm lại: Đừng chỉ đọc lại. Hãy dừng lại, che tài liệu đi, và tự hỏi: "Mình thực sự nhớ được gì?"</i></p>`
                },
                {
                    id: uid('m'),
                    title: 'Lặp Lại Ngắt Quãng (Spaced Repetition): Học Đúng Thời Điểm',
                    content: `<p>Nếu Gợi nhớ chủ động là về cách học, thì Lặp lại ngắt quãng là về thời điểm học. Đây là một hệ thống lên lịch ôn tập để đưa thông tin vào trí nhớ dài hạn một cách hiệu quả nhất.</p><h4>Nguyên Tắc Cốt Lõi: Chống Lại Sự Lãng Quên 🧠</h4><p>Phương pháp này dựa trên "Đường cong Lãng quên", cho thấy chúng ta quên thông tin nhanh nhất ngay sau khi học. Lặp lại ngắt quãng hoạt động bằng cách yêu cầu bạn ôn tập lại một thông tin ngay trước khi bạn sắp quên nó.</p><p>Mỗi lần ôn tập thành công sẽ làm cho khoảng thời gian bạn nhớ thông tin đó dài ra. Lần đầu bạn có thể quên sau 1 ngày, nhưng sau khi ôn tập, bạn sẽ nhớ được trong 3 ngày, rồi 1 tuần, 1 tháng, và cứ thế xa dần.</p><h4>Công Cụ Hiệu Quả Nhất: Phần Mềm SRS 📱</h4><p>Thay vì tự lên lịch thủ công, cách hiệu quả nhất là sử dụng các phần mềm Lặp lại ngắt quãng (Spaced Repetition Software - SRS). Anki được xem là tiêu chuẩn vàng. Nó tự động hóa hoàn toàn việc lên lịch ôn tập cho hàng ngàn thẻ ghi nhớ dựa trên độ khó mà bạn tự đánh giá, đảm bảo bạn luôn ôn tập vào thời điểm tối ưu nhất.</p><h4>Sai Lầm Lớn Nhất Cần Tránh ❌</h4><p>Lý do số một khiến mọi người thất bại với phương pháp này là "Quá tải Lịch ôn tập" (Review Overload). Điều này xảy ra khi bạn tạo quá nhiều thẻ mới mỗi ngày hoặc bỏ lỡ vài ngày ôn tập, dẫn đến một lượng thẻ tồn đọng khổng lồ gây nản chí.</p><p><strong>Giải pháp (20% hành động, 80% kết quả):</strong> Hãy nhất quán. Đặt ra giới hạn thực tế về số lượng thẻ mới mỗi ngày (ví dụ: 10-20 thẻ) và duy trì việc ôn tập hàng ngày. Thà học ít mà đều còn hơn học dồn.</p><h4>Sự Kết Hợp Sống Còn: AR + SR</h4><p>Lặp lại ngắt quãng (SR) và Gợi nhớ chủ động (AR) là hai mặt của cùng một đồng xu và không thể tách rời. SR cung cấp lịch trình KHI NÀO nên ôn tập. AR là hành động bạn thực hiện KHI ôn tập. Sự kết hợp này đảm bảo nỗ lực gợi nhớ của bạn xảy ra vào "điểm ngọt" của trí nhớ. Sử dụng Anki chính là cách triển khai kỹ thuật kết hợp này một cách hiệu quả nhất.</p>`
                }
            ]
        },
        topics: []
    };
    // Đồng nhất logic: loại bỏ kho tri thức toàn cục trong defaults (chỉ dùng per-subtopic)
    try { delete defaults.settings.methods; } catch(_) {}
    let data;
    let editingPreset = 'A';

    // (Các hàm còn lại giữ nguyên)
    // ...
    // ...
    // callGeminiAPI unified at the end of file (single source of truth)
    let AUDIO_CTX = null;
    function ensureAudio(){ if(!AUDIO_CTX) AUDIO_CTX = new (window.AudioContext||window.webkitAudioContext)(); }
    function tone(freq=880, durMs=200, vol=0.2, type='sine', when=0){ ensureAudio(); const ctx=AUDIO_CTX; const o=ctx.createOscillator(); const g=ctx.createGain(); o.type=type; o.frequency.value=freq; o.connect(g); g.connect(ctx.destination); const t = ctx.currentTime + when; g.gain.setValueAtTime(0, t); g.gain.linearRampToValueAtTime(vol, t+0.01); g.gain.exponentialRampToValueAtTime(0.0001, t + durMs/1000); o.start(t); o.stop(t + durMs/1000 + 0.05); }
    function playSound(kind){
      if(!data.settings.soundOn) return;
      const vol = Math.max(0, Math.min(1, data.settings.volume ?? 0.8));
      const useCustom = !!data.settings.useCustomSounds;
      const ref = useCustom ? data.settings.customSounds?.[kind] : '';
      let audioEl;
      if (kind === 'work_end') audioEl = $('#audioWorkEnd'); else if (kind === 'break_end') audioEl = $('#audioBreakEnd'); else if (kind === 'long_end') audioEl = $('#audioLongEnd');
      if (ref && audioEl) {
        if (ref.startsWith('data:') || ref.startsWith('http') || ref.startsWith('blob:')) {
            audioEl.src = ref;
            audioEl.volume = vol;
            audioEl.play().catch(e => console.error("Lỗi phát âm thanh:", e));
        } else {
            getStoredFileUrl(ref).then(url => {
                if (url) {
                    audioEl.src = url;
                    audioEl.volume = vol;
                    audioEl.play().catch(e => console.error("Lỗi phát âm thanh:", e));
                }
            });
        }
        return;
      }
      const theme = data.settings.soundTheme || 'beep';
      if(theme==='beep'){
        if(kind==='work_end') { tone(880,250,vol); tone(660,180,vol*0.8, 'sine', 0.22); } else if(kind==='break_end') { tone(660,220,vol*0.9); } else if(kind==='long_end') { tone(520,200,vol); tone(780,200,vol, 'sine', 0.22); tone(1040,220,vol, 'sine', 0.44); }
      } else {
        if(kind==='work_end') { tone(1200,160,vol*0.9,'triangle'); tone(900,220,vol*0.8,'triangle',0.18); } else if(kind==='break_end') { tone(880,240,vol*0.8,'triangle'); } else if(kind==='long_end') { tone(600,220,vol*0.9,'triangle'); tone(950,240,vol*0.9,'triangle',0.22); tone(1200,240,vol,'triangle',0.44); }
      }
    }
      async function saveData() {
        try {
          await storageManager.save(data);
        } catch (err) {
          console.error('Failed to save data:', err);
          toast(`Lỗi lưu dữ liệu: ${err.message}`);
        }
      }
        async function ensureValidSelection(){
          const set = data.settings;
          if (!data.topics || data.topics.length === 0) { set.selectedTopicId = ''; set.selectedSubtopicId = ''; await saveData(); return; }
          const t = data.topics.find(x=>x.id===set.selectedTopicId);
          const s = t?.subtopics.find(x=>x.id===set.selectedSubtopicId);
          if(!t || !s){
            const t0 = data.topics[0];
            const s0 = t0?.subtopics?.[0];
            set.selectedTopicId = t0?.id || '';
            set.selectedSubtopicId = s0?.id || '';
            await saveData();
          }
        }
    function showInputModal(title, okCallback, defaultValue = '') {
        $('#genericTitle').textContent = title;
        $('#genericMessage').classList.add('hidden');
        const input = $('#genericInput'); input.value = defaultValue; input.classList.remove('hidden');
        $('#modalGeneric').classList.add('show');
        try { trapFocus($('#modalGeneric')); } catch(_) {}
        input.focus(); input.select();
        const okHandler = () => { okCallback(input.value); cleanup(); };
        const cancelHandler = () => cleanup();
        const keyHandler = (e) => { if (e.key === 'Enter') okHandler(); if (e.key === 'Escape') cancelHandler(); };
        $('#btnGenericOk').onclick = okHandler; $('#btnGenericCancel').onclick = cancelHandler; input.onkeydown = keyHandler;
        function cleanup() { $('#modalGeneric').classList.remove('show'); $('#btnGenericOk').onclick = null; $('#btnGenericCancel').onclick = null; input.onkeydown = null; try { releaseFocus(); } catch(_) {} }
    }
    function showConfirmModal(title, message, okCallback) {
        $('#genericTitle').textContent = title;
        const msgEl = $('#genericMessage'); msgEl.textContent = message; msgEl.classList.remove('hidden');
        $('#genericInput').classList.add('hidden'); $('#modalGeneric').classList.add('show');
        try { trapFocus($('#modalGeneric')); } catch(_) {}
        const okHandler = () => { okCallback(true); cleanup(); };
        const cancelHandler = () => { okCallback(false); cleanup(); };
        $('#btnGenericOk').onclick = okHandler; $('#btnGenericCancel').onclick = cancelHandler;
        function cleanup() { $('#modalGeneric').classList.remove('show'); $('#btnGenericOk').onclick = null; $('#btnGenericCancel').onclick = null; try { releaseFocus(); } catch(_) {} }
    }
    // Modal ghi chú cho phiên vừa hoàn thành
    let pendingNoteSessionId = null;
    function openNoteModal(sessionId) {
        pendingNoteSessionId = sessionId || null;
        const modal = $('#modalNote');
        if (!modal) return;
        const text = $('#noteText');
        if (text) { try { text.value = ''; } catch(_) {} }
        modal.classList.add('show');
        try { trapFocus(modal); } catch(_) {}
    }
    function closeNoteModal() {
        const modal = $('#modalNote');
        if (!modal) return;
        modal.classList.remove('show');
        pendingNoteSessionId = null;
        try { releaseFocus(); } catch(_) {}
    }
    async function switchView(viewId) {
        $$('.view').forEach(v => v.classList.remove('active'));
        $(`#view-${viewId}`).classList.add('active');
        $$('.nav-btn').forEach(b => b.classList.remove('active'));
        const navBtn = $(`.nav-btn[data-view="${viewId}"]`);
        if (navBtn) navBtn.classList.add('active');
        data.settings.currentView = viewId;
        await saveData();
        if (viewId === 'stats') {
            renderDashboard();
        }
    }
    function closeAllMenus() {
        $$('.actions-menu.show').forEach(menu => menu.classList.remove('show'));
        $$('.topic-item.menu-active').forEach(item => item.classList.remove('menu-active'));
    }
    function renderTopics(){
      const wrap = $('#topicsList');
      if (!wrap) return;
      wrap.innerHTML='';
      const collapsedMap = data.settings.collapsedTopics || {};
      data.topics.forEach(topic => {
        const box = document.createElement('div');
        box.className='topic-item';
        box.dataset.tid = topic.id;
        const header = document.createElement('div');
        header.className='topic-header';
        const isCollapsed = !!collapsedMap[topic.id];
        const chev = document.createElement('button');
        chev.className = 'chev btn small ghost';
        chev.setAttribute('aria-expanded', String(!isCollapsed));
        chev.innerHTML = '<span class="ico">▾</span>';
        const title = document.createElement('div');
        title.className='topic-title';
        title.textContent = topic.name;
        const act = document.createElement('div');
        act.className='topic-actions';
        const bAdd = document.createElement('button');
        bAdd.className='btn small';
        bAdd.innerHTML = '＋ Thêm';
        bAdd.title = 'Thêm Chủ đề con';
        const menuContainer = document.createElement('div');
        menuContainer.style.position = 'relative';
        const bMore = document.createElement('button');
        bMore.className = 'btn small ghost actions-menu-btn';
        bMore.innerHTML = '...';
        bMore.title = 'Thêm tùy chọn';
        const menu = document.createElement('div');
        menu.className = 'actions-menu';
        const bEdit = document.createElement('button');
        bEdit.className = 'menu-item';
        bEdit.innerHTML = 'Sửa tên Chủ đề';
        const bDel = document.createElement('button');
        bDel.className = 'menu-item danger';
        bDel.innerHTML = 'Xóa Chủ đề';
        menu.append(bEdit, bDel);
        menuContainer.append(bMore, menu);
        act.append(bAdd, menuContainer);
        header.append(chev, title, act);
        // Chevron toggles collapse/expand of subtopics
        chev.addEventListener('click', async (e) => {
          e.stopPropagation();
          const currentlyCollapsed = !!collapsedMap[topic.id];
          if (currentlyCollapsed) { delete collapsedMap[topic.id]; } else { collapsedMap[topic.id] = true; }
          data.settings.collapsedTopics = collapsedMap;
          await storageManager.updateSettings(data.settings);
          renderTopics();
        });
        const toggleTopic = async () => {
          const currentlyCollapsed = !!collapsedMap[topic.id];
          if (currentlyCollapsed) { delete collapsedMap[topic.id]; } else { collapsedMap[topic.id] = true; }
          data.settings.collapsedTopics = collapsedMap;
          await storageManager.updateSettings(data.settings);
          renderTopics();
        };
        // Allow clicking the topic header to toggle subtopics
        // (ignore clicks on actual interactive controls only)
        header.addEventListener('click', async (e) => {
          const t = e.target;
          if (t && t.closest) {
            if (t.closest('.actions-menu') || t.closest('.actions-menu-btn') || t.closest('button') || t.closest('input,select,textarea')) {
              return; // user interacted with a control, don't toggle
            }
          }
          e.stopPropagation();
          await toggleTopic();
        });
        // Make the title area itself a large click target to toggle
        title.addEventListener('click', async (e) => { e.stopPropagation(); await toggleTopic(); });
        // Also allow clicking anywhere on the topic card (outside subtopics and controls) to toggle
        box.addEventListener('click', async (e) => {
          const t = e.target;
          if (t && t.closest) {
            if (t.closest('.subtopics')) return;
            if (t.closest('.actions-menu') || t.closest('.actions-menu-btn') || t.closest('button') || t.closest('input,select,textarea')) return;
          }
          await toggleTopic();
        });
        const subs = document.createElement('div');
        subs.className='subtopics' + (isCollapsed? ' hidden':'');
        subs.dataset.tid = topic.id;
        topic.subtopics.forEach(st => {
          const row = document.createElement('div');
          row.className='sub-row';
          row.dataset.sid = st.id;
          const btn = document.createElement('button');
          btn.className='btn subtopic-btn';
          // Bọc văn bản trong span để xử lý tràn tốt hơn và escape HTML
          btn.innerHTML = `<span>• ${escapeHTML(st.name)}</span>`;
          btn.dataset.sid = st.id;
          btn.dataset.tid = topic.id;
          if(data.settings.selectedSubtopicId===st.id) btn.classList.add('active');
          const subActions = document.createElement('div');
          subActions.className = 'actions';
          const subMenuContainer = document.createElement('div');
          subMenuContainer.style.position = 'relative';
          const subBMore = document.createElement('button');
          subBMore.className = 'btn small ghost actions-menu-btn';
          subBMore.innerHTML = '...';
          subBMore.title = 'Thêm tùy chọn';
          const subMenu = document.createElement('div');
          subMenu.className = 'actions-menu';
          const subBEdit = document.createElement('button');
          subBEdit.className = 'menu-item';
          subBEdit.innerHTML = 'Sửa tên Chủ đề con';
          const subBDel = document.createElement('button');
          subBDel.className = 'menu-item danger';
          subBDel.innerHTML = 'Xóa Chủ đề con';
          subMenu.append(subBEdit, subBDel);
          subMenuContainer.append(subBMore, subMenu);
          subActions.append(subMenuContainer);
          row.append(btn, subActions);
          subs.appendChild(row);
          btn.addEventListener('click', ()=> selectSubtopic(topic.id, st.id));
          subBMore.addEventListener('click', (e) => {
            e.stopPropagation();
            const isOpen = subMenu.classList.contains('show');
            closeAllMenus();
            if (isOpen) {
              // Đang mở => đóng và KHÔNG mở lại
              box.classList.remove('menu-active');
            } else {
              // Đang đóng => mở menu này và nâng z-index
              subMenu.classList.add('show');
              box.classList.add('menu-active');
            }
          });
          subBEdit.addEventListener('click', ()=> showInputModal('Đổi tên Chủ đề con', async (newName) => { if(!newName) return; st.name=newName; await storageManager.update('subtopics', st); renderAll(); }, st.name));
          subBDel.addEventListener('click', ()=> showConfirmModal('Xác nhận xóa', `Bạn có chắc muốn xóa Chủ đề con "${st.name}"? Mọi dữ liệu liên quan sẽ bị mất.`, async (ok) => { if(!ok) return; topic.subtopics = topic.subtopics.filter(x=>x.id!==st.id); const set=data.settings; if(set.selectedSubtopicId===st.id){ set.selectedSubtopicId=''; set.selectedTopicId=''; ensureValidSelection(); } await storageManager.delete('subtopics', st.id); renderAll(); }));
        });
        
        bMore.addEventListener('click', (e) => {
          e.stopPropagation();
          const isOpen = menu.classList.contains('show');
          closeAllMenus();
          if (isOpen) {
            // Đang mở => đóng và KHÔNG mở lại
            box.classList.remove('menu-active');
          } else {
            // Đang đóng => mở menu này và nâng z-index
            menu.classList.add('show');
            box.classList.add('menu-active');
          }
        });
        bAdd.addEventListener('click', ()=> showInputModal('Tên Chủ đề con mới?', async (name) => { if(!name) return; const newSub = { id: uid('s'), topicId: topic.id, name, tasks: [], generalNotes: [], summaries: [], chatHistory: [], methods: [], stats:{ totalMinutes:0, sessionsCompleted:0, tasksCompleted: 0 }, sessions: [], timerState: { state: 'idle', prevState: null, remaining: 0, segmentTotal: 0, cycleIndex: 0 } }; topic.subtopics.push(newSub); await storageManager.add('subtopics', newSub); renderTopics(); }));
        bEdit.addEventListener('click', ()=> showInputModal('Đổi tên Chủ đề', async (newName) => { if(!newName) return; topic.name=newName; await storageManager.update('topics', topic); renderTopics(); }, topic.name));
        bDel.addEventListener('click', ()=> showConfirmModal('Xác nhận xóa', `Bạn có chắc muốn xóa Chủ đề "${topic.name}"? Mọi chủ đề con và dữ liệu liên quan sẽ bị mất.`, async (ok) => { if(!ok) return; data.topics = data.topics.filter(t=>t.id!==topic.id); delete collapsedMap[topic.id]; if(data.settings.selectedTopicId===topic.id){ data.settings.selectedTopicId=''; data.settings.selectedSubtopicId=''; ensureValidSelection(); } await storageManager.delete('topics', topic.id); for(const sub of topic.subtopics){ await storageManager.delete('subtopics', sub.id); } renderAll(); }));
        // Prevent header toggle when clicking action buttons
        bAdd.addEventListener('click', (e)=> e.stopPropagation());
        bEdit.addEventListener('click', (e)=> e.stopPropagation());
        bDel.addEventListener('click', (e)=> e.stopPropagation());
        box.append(header, subs);
        wrap.appendChild(box);
      });
      if (window.Sortable) {
        const topicsListEl = document.getElementById('topicsList');
        if (topicsListEl) {
          if (topicsListEl._sortable) { try { topicsListEl._sortable.destroy(); } catch (e) {} }
          topicsListEl._sortable = new Sortable(topicsListEl, {
            animation: 150,
            draggable: '.topic-item',
            onEnd: async function (evt) {
              if (evt.oldIndex === evt.newIndex) return;
              const moved = data.topics.splice(evt.oldIndex, 1)[0];
              data.topics.splice(evt.newIndex, 0, moved);
              await saveData();
              renderTopics();
            }
          });
          topicsListEl.querySelectorAll('.subtopics').forEach(subsEl => {
            new Sortable(subsEl, {
              group: 'subtopics-group',
              animation: 150,
              draggable: '.sub-row',
              onEnd: async function (evt) {
                const fromTopicId = evt.from?.dataset?.tid || evt.from?.closest('.topic-item')?.dataset?.tid;
                const toTopicId = evt.to?.dataset?.tid || evt.to?.closest('.topic-item')?.dataset?.tid;
                const fromTopic = data.topics.find(t => t.id === fromTopicId);
                const toTopic = data.topics.find(t => t.id === toTopicId);
                if (!fromTopic || !toTopic) return;
                let movedSubtopic = null;
                const movedSid = evt.item?.dataset?.sid || evt.item?.querySelector('.subtopic-btn')?.dataset?.sid;
                if (movedSid) {
                  const idx = fromTopic.subtopics.findIndex(s => s.id === movedSid);
                  if (idx >= 0) movedSubtopic = fromTopic.subtopics.splice(idx, 1)[0];
                }
                if (!movedSubtopic) {
                  movedSubtopic = fromTopic.subtopics.splice(evt.oldIndex, 1)[0];
                }
                if (!movedSubtopic) return;
                movedSubtopic.topicId = toTopic.id;
                toTopic.subtopics.splice(evt.newIndex, 0, movedSubtopic);
                if (data.settings.selectedSubtopicId === movedSubtopic.id) {
                  data.settings.selectedTopicId = toTopic.id;
                }
                await saveData();
                renderTopics();
              }
            });
          });
        }
      }
    }
    function selectSubtopic(topicId, subId) {
        const mainEl = $('.app-content');
        const oldSubtopic = getCurrentSubtopic();
        if (oldSubtopic && timer.state !== 'idle') {
            oldSubtopic.timerState = {
                state: timer.state,
                prevState: timer.prevState,
                remaining: timer.remaining,
                segmentTotal: timer.segmentTotal,
                cycleIndex: timer.cycleIndex
            };
        }
        mainEl.classList.add('reloading');
        setTimeout(async () => {
            data.settings.selectedTopicId = topicId;
            data.settings.selectedSubtopicId = subId;
            const newSubtopic = getCurrentSubtopic();
            if (newSubtopic.timerState) {
                timer.state = newSubtopic.timerState.state;
                timer.prevState = newSubtopic.timerState.prevState || null;
                timer.remaining = newSubtopic.timerState.remaining;
                timer.segmentTotal = newSubtopic.timerState.segmentTotal;
                timer.cycleIndex = newSubtopic.timerState.cycleIndex;
            } else {
                timer.reset();
            }
            await saveData();
            timer.updateUI();
            renderAll();
            switchView('timer');
            mainEl.classList.remove('reloading');
        }, 200);
    }
    function getCurrentSubtopic(){ const tid=data.settings.selectedTopicId, sid=data.settings.selectedSubtopicId; if(!tid||!sid) return null; const t=data.topics.find(x=>x.id===tid); if(!t) return null; return t.subtopics.find(x=>x.id===sid) || null; }
    function renderContextBadge(){
      const s=getCurrentSubtopic();
      const name = s ? s.name : '(chưa chọn)';
      const selectedContext = $('#selectedContext');
      const currentName = $('#currentSubtopicName');
      const currentChatName = $('#currentSubtopicNameChat');
      if (selectedContext) selectedContext.textContent = s? `Chủ đề con: ${s.name}`:'Chưa chọn Chủ đề con';
      if (currentName) currentName.textContent = name;
      if (currentChatName) currentChatName.textContent = name;
    }
    function renderSubtopicTasks() {
        const s = getCurrentSubtopic();
        const listEl = $('#subtopicTasksList');
        const inputEl = $('#newSubtopicTaskInput');
        if (!listEl || !inputEl) return;
        const addArea = inputEl.parentElement;
        if (!s) {
            listEl.innerHTML = '<li class="tiny" style="opacity: 0.7;">Chọn chủ đề con để xem to-do list.</li>';
            addArea.classList.add('hidden'); return;
        }
        addArea.classList.remove('hidden');
        listEl.innerHTML = '';
        const uncompletedTasks = s.tasks ? s.tasks.filter(t => !t.isCompleted) : [];

        if (uncompletedTasks.length === 0) {
            listEl.innerHTML = '<li class="tiny" style="opacity: 0.7;">Tuyệt vời! Không còn task nào.</li>';
        }
        uncompletedTasks.forEach(task => {
            const item = document.createElement('li');
            item.innerHTML = `<input type="checkbox" id="${task.id}" title="Hoàn thành task"> <label for="${task.id}">${escapeHTML(task.text)}</label>`;
            item.querySelector('input').addEventListener('change', (e) => toggleSubtopicTask(e.target.id, item));
            listEl.appendChild(item);
        });
    }
    async function addSubtopicTask() {
        const s = getCurrentSubtopic();
        if (!s) { toast(t('timer.selectSubtopicPrompt')); return; }
        const input = $('#newSubtopicTaskInput');
        const text = input.value.trim();
        if (text) {
            if (!s.tasks) s.tasks = [];
            s.tasks.push({ id: uid('task'), text, isCompleted: false, createdAt: todayISO() });
            await saveData();
            renderSubtopicTasks();
            input.value = '';
        }
        input.focus();
    }
    async function toggleSubtopicTask(taskId, listItemElement) {
        const s = getCurrentSubtopic();
        if (!s || !s.tasks) return;
        const task = s.tasks.find(t => t.id === taskId);
        if (task) {
            task.isCompleted = true;
            s.stats.tasksCompleted = (s.stats.tasksCompleted || 0) + 1;
            await saveData();
            listItemElement.classList.add('removing');
            setTimeout(() => {
                renderSubtopicTasks();
                renderStatsHistory();
            }, 200);
        }
    }
    const timer = {
      state:'idle', prevState:null, tickHandle:null, endAt:null,
      remaining:0, segmentTotal:0, cyclesTarget:4, cycleIndex:0, mode:'A',
      persistInterval: 60*1000,
      lastPersist: 0,
      async setPreset(p, {silent=false}={}){
        const st = data.settings;
        this.mode = p;
        this.cyclesTarget = (p==='A' ? st.cyclesA : (p==='B' ? st.cyclesB : 0));
        st.preset = p;
        await saveData();
        if (this.state === 'idle') {
          this.reset();
        }
      },
      currentDurations(){
        const d=data.settings.durations;
        if(this.mode==='A') return {work:d.A_work, short:d.A_short, long:d.A_long, winddown: d.A_winddown ?? 0};
        if(this.mode==='B') return {work:d.B_work, short:d.B_short, long:d.B_long, winddown: d.B_winddown ?? 0};
        return {work:0, short:0, long:0, winddown:0};
      },
      currentConfig(){ const s=data.settings; if(this.mode==='A') return {cycles:s.cyclesA, interval:s.longBreakIntervalA}; if(this.mode==='B') return {cycles:s.cyclesB, interval:s.longBreakIntervalB}; return {cycles:0, interval:0}; },
      updateUI() {
        const badge = $('#stateBadge');
        const progressCircle = $('.timer-circle-progress');
        const container = $('.timer-circle-container');
        if (!badge || !progressCircle || !container) return;
        const isFlowMode = (this.mode === 'C');
        $('#btnStart').classList.toggle('hidden', this.state !== 'idle' || (isFlowMode && this.state === 'work'));
        $('#btnFinishFlow').classList.toggle('hidden', !(isFlowMode && this.state === 'work'));
        $('#btnPause').classList.toggle('hidden', !['work', 'break', 'long_break'].includes(this.state));
        $('#btnResume').classList.toggle('hidden', this.state !== 'paused');
        let currentColor = 'var(--muted)';
        if (this.state === 'work') { badge.textContent = isFlowMode ? 'LÀM VIỆC (FLOW)' : 'LÀM VIỆC'; badge.className = 'badge state work'; currentColor = 'var(--acc)'; }
        else if (this.state === 'break') { badge.textContent = 'NGHỈ NGẮN'; badge.className = 'badge state break'; currentColor = 'var(--warn)'; }
        else if (this.state === 'long_break') { badge.textContent = 'NGHỈ DÀI'; badge.className = 'badge state long'; currentColor = 'var(--danger)'; }
        else if (this.state === 'wind_down') { badge.textContent = 'HẠ NHIỆT'; badge.className = 'badge state work'; currentColor = 'var(--acc-2)'; try { $('#windDownChecklist').classList.remove('hidden'); $('#btnBreakEarly').classList.remove('hidden'); } catch(_){} }
        else if (this.state === 'paused') { badge.textContent = 'TẠM DỪNG'; badge.className = 'badge'; }
        else { badge.textContent = 'SẴN SÀNG'; badge.className = 'badge'; }
        try {
          if (this.state === 'work') badge.textContent = isFlowMode ? t('stateBadgeFocusFlow') : t('stateBadgeFocus');
          else if (this.state === 'break') badge.textContent = t('stateBadgeShortBreak');
          else if (this.state === 'long_break') badge.textContent = t('stateBadgeLongBreak');
          else if (this.state === 'wind_down') badge.textContent = t('stateBadgeWindDown');
          else if (this.state === 'paused') badge.textContent = t('stateBadgePaused');
          else badge.textContent = t('stateBadgeReady');
        } catch(_) {}
        if (['work','break','long_break','wind_down'].includes(this.state)) { container.classList.add('breathing'); } else { container.classList.remove('breathing'); }
        progressCircle.style.stroke = currentColor; container.classList.remove('finished');
        const timeEl = $('#timeDisplay'); if (timeEl) timeEl.textContent = formatMMSS(this.remaining);
        const radius = progressCircle.r.baseVal.value; const circumference = 2 * Math.PI * radius;
        const offset = (this.segmentTotal>0) ? (circumference - (this.remaining / this.segmentTotal) * circumference) : circumference;
        progressCircle.style.strokeDasharray = circumference;
        progressCircle.style.strokeDashoffset = isNaN(offset) ? circumference : offset;
        const cyc = $('#cycleInfo'); if (cyc) { const cfg=this.currentConfig(); cyc.textContent = t('timer.cycleInfo', { current: this.cycleIndex, target: cfg.cycles }); cyc.classList.toggle('hidden', isFlowMode); }
        const bs = $('#breakSuggestionDisplay'); if (bs) { bs.classList.toggle('hidden', isFlowMode && this.state === 'work'); }
        const draggableTimer = $('#draggableTimer'); if (draggableTimer) draggableTimer.textContent = formatMMSS(this.remaining);
        if (this.state !== 'wind_down') {
          try { $('#windDownChecklist').classList.add('hidden'); $('#btnBreakEarly').classList.add('hidden'); } catch(_){}
        }
      },
      persistTimerState(force=false){
        try{
          const s = getCurrentSubtopic(); if(!s) return;
          const state = { state:this.state, prevState:this.prevState, remaining:this.remaining, segmentTotal:this.segmentTotal, cycleIndex:this.cycleIndex };
          s.timerState = state; try{ localStorage.setItem('timerState_'+s.id, JSON.stringify(state)); }catch(_){ }
          this.lastPersist = Date.now();
        }catch(_){ }
      },
      _startTick(){
        if(this.tickHandle) clearInterval(this.tickHandle);
        if (this.mode === 'C' && this.state === 'work') {
          this.tickHandle = setInterval(()=>{ this.remaining += 1; this.updateUI(); this.persistTimerState(); }, 1000);
          return;
        }
        this.tickHandle = setInterval(()=>{ if(this.remaining>0){ this.remaining -= 1; this.updateUI(); this.persistTimerState(); } if(this.remaining<=0){ clearInterval(this.tickHandle); this.tickHandle=null; this._onFinishSegment(); } }, 1000);
      },
      _onFinishSegment(){
        if (this.state === 'work') {
            const s = getCurrentSubtopic();
            if (s) {
                const duration = this.currentDurations().work;
                s.stats.totalMinutes = (s.stats.totalMinutes || 0) + duration;
                s.stats.sessionsCompleted = (s.stats.sessionsCompleted || 0) + 1;
                const newSession = {
                    id: uid('sess'),
                    dateISO: todayISO(),
                    durationMinutes: duration,
                    mode: this.mode,
                    note: ''
                };
                if (!s.sessions) s.sessions = [];
                s.sessions.unshift(newSession);
                if (data?.settings?.enableSessionNotes !== false) {
                    try { openNoteModal(newSession.id); } catch(_) {}
                }
                saveData();
                renderStatsHistory();
                checkAndShowMilestones();
            }
            this.cycleIndex++;
        }
        if ((typeof data !== 'undefined') && data && data.settings && data.settings.enableWinddown === false && this.state === 'work') {
          playSound('work_end');
        } else if (this.state === 'wind_down' || this.state === 'break' || this.state === 'long_break') {
          playSound('break_end');
        }
        const container = $('.timer-circle-container');
        if(container) container.classList.add('finished');
        if (data.settings.autoStartNext) {
          if(this.state==='work'){
            if (data.settings.enableWinddown === false) { this.beginBreak(); }
            else { this.beginWindDown(); }
          } else if (this.state === 'wind_down') {
            this.beginBreak();
          } else {
            this.beginWork();
          }
        } else {
          if(this.tickHandle){ clearInterval(this.tickHandle); this.tickHandle=null; }
          this.state = 'idle';
          this.prevState = null;
          this.updateUI();
          toast("Phiên đã hoàn thành! Nhấn Bắt đầu để bắt đầu phiên tiếp theo.");
        }
      },
      beginWindDown(){
        if (data?.settings?.enableWinddown === false) { this.beginBreak(); return; }
        this.prevState = this.state;
        this.state = 'wind_down';
        const d = (this.currentDurations().winddown || 0) * 60;
        if (d <= 0) { this.beginBreak(); return; }
        this.segmentTotal = d;
        this.remaining = d;
        try { playSound('break_end'); } catch(_){}
        try { toast('Đến giờ hạ nhiệt. Hãy kết thúc công việc và chuẩn bị nghỉ ngơi.'); } catch(_){}
        this._startTick();
        this.updateUI();
      },
      beginWork(){
        this.prevState = this.state;
        this.state = 'work';
        if (this.mode === 'C') {
          this.segmentTotal = 0;
          if (this.prevState !== 'paused') this.remaining = 0; // đếm lên từ 0
        } else {
          const d = this.currentDurations().work * 60;
          this.segmentTotal = d;
          if (this.prevState !== 'paused') this.remaining = d;
        }
        const suggestionEl = $('#breakSuggestionDisplay');
        if (suggestionEl) { suggestionEl.textContent = ''; }
        this._startTick();
        this.updateUI();
      },
      finishFlowSession(){
        if (this.mode !== 'C' || this.state !== 'work') return;
        if (this.tickHandle) { clearInterval(this.tickHandle); this.tickHandle = null; }
        const ratio = Math.max(1, parseInt((data.settings.flowtimeBreakRatio ?? 5), 10));
        const workSec = Math.max(0, this.remaining|0);
        const restSec = Math.max(60, Math.floor(workSec / ratio));
        // Ghi lại một session cho Flow và mở modal ghi chú
        try {
          const s = getCurrentSubtopic();
          if (s) {
            const minutes = Math.max(1, Math.round(workSec / 60));
            s.stats.totalMinutes = (s.stats.totalMinutes || 0) + minutes;
            s.stats.sessionsCompleted = (s.stats.sessionsCompleted || 0) + 1;
            const newSession = { id: uid('sess'), dateISO: todayISO(), durationMinutes: minutes, mode: this.mode, note: '' };
            if (!s.sessions) s.sessions = [];
            s.sessions.unshift(newSession);
            saveData();
            renderStatsHistory();
            if (data?.settings?.enableSessionNotes !== false) {
              openNoteModal(newSession.id);
            }
          }
        } catch(_) {}
        this.state = 'break';
        this.segmentTotal = restSec;
        this.remaining = restSec;
        this._startTick();
        this.updateUI();
        this.persistTimerState(true);
        try { toast(`Nghỉ ${Math.round(restSec/60)} phút theo Flowtime (${ratio}).`); } catch(_) {}
      },
      beginBreak() {
        this.prevState = this.state;
        const config = this.currentConfig();
        const durations = this.currentDurations();
        if (this.cycleIndex > 0 && this.cycleIndex % config.interval === 0) {
          this.state = 'long_break';
          const d = durations.long * 60;
          this.segmentTotal = d;
          if (this.prevState !== 'paused') this.remaining = d;
          toast(`Tuyệt vời! Đã đến lúc nghỉ dài.`);
        } else {
          this.state = 'break';
          const d = durations.short * 60;
          this.segmentTotal = d;
          if (this.prevState !== 'paused') this.remaining = d;
        }
        // Hiển thị gợi ý khi bắt đầu nghỉ
        const suggestionEl = $('#breakSuggestionDisplay');
        if (suggestionEl) {
          const randomIndex = Math.floor(Math.random() * breakSuggestions.length);
          suggestionEl.textContent = `💡 Gợi ý: ${breakSuggestions[randomIndex]}`;
        }
        this._startTick();
        this.updateUI();
      },
      async start(){ if(!getCurrentSubtopic()){ toast('Hãy chọn một Chủ đề con trước khi bắt đầu'); return; } ensureAudio(); if(this.mode==='C' && this.state==='idle'){ this.state='work'; this.remaining=0; this.segmentTotal=0; this.cycleIndex=0; this._startTick(); this.updateUI(); } else if(this.state==='idle'){ this.cycleIndex = this.cycleIndex || 0; this.beginWork(); } else if(this.state==='paused'){ this.resume(); } await this.persistTimerState(true); },
      async pause(){ if(this.tickHandle){ clearInterval(this.tickHandle); this.tickHandle=null; } this.prevState=this.state; this.state='paused'; this.updateUI(); await this.persistTimerState(true); },
      async resume(){ if(this.state!=='paused'){ return; } this.state=this.prevState||'work'; this._startTick(); this.updateUI(); await this.persistTimerState(true); },
      async skip(){
        if(this.mode==='C' && this.state==='work'){ this.finishFlowSession(); await this.persistTimerState(true); return; }
        if(this.state==='work'){
          if(this.tickHandle){ clearInterval(this.tickHandle); this.tickHandle=null; }
          this.remaining = 0;
          this._onFinishSegment();
        } else {
          this.remaining=0; if(this.tickHandle){ clearInterval(this.tickHandle); this.tickHandle=null; } this._onFinishSegment();
        }
        await this.persistTimerState(true);
      },
      async reset(){
        if (this.tickHandle) { clearInterval(this.tickHandle); this.tickHandle = null; }
        this.state = 'idle';
        this.prevState = null;
        this.remaining = 0;
        this.segmentTotal = 0;
        this.cycleIndex = 0;
        // Xóa gợi ý khi đặt lại
        const suggestionEl = $('#breakSuggestionDisplay');
        if (suggestionEl) { suggestionEl.textContent = ''; }
        this.updateUI();
        await this.persistTimerState(true);
      }
    };
    async function deleteSummary(id) {
        showConfirmModal('Xác nhận xóa', 'Bạn có chắc muốn xóa tóm tắt này?', async (ok) => {
            if (!ok) return;
            const s = getCurrentSubtopic();
            if (!s || !s.summaries) return;
            const original = [...s.summaries];
            s.summaries = s.summaries.filter(x => x.id !== id);
            try {
                await storageManager.update('subtopics', s);
                renderSummaries();
                toast('Đã xóa tóm tắt.');
            } catch (err) {
                console.error('Failed to delete summary:', err);
                s.summaries = original;
                toast('Không thể lưu thay đổi.');
            }
        });
    }
function exportSummary(sum) {
        const blob = new Blob([sum.content], { type: 'text/plain' });
        const a = document.createElement('a');
        const ts = new Date(sum.createdAt);
        const pad = n => `${n}`.padStart(2, '0');
        a.href = URL.createObjectURL(blob);
        a.download = `summary_${ts.getFullYear()}${pad(ts.getMonth()+1)}${pad(ts.getDate())}.txt`;
        a.click();
        URL.revokeObjectURL(a.href);
}
    function renderStatsHistory(){
        const s = getCurrentSubtopic();
        const statTotal = $('#statTotal');
        const statSessions = $('#statSessions');
        const statTasks = $('#statTasks');
        const list = $('#historyList');
        if (!statTotal || !statSessions || !statTasks || !list) return;

        if (!s) {
            statTotal.textContent = '0 phút';
            statSessions.textContent = '0';
            statTasks.textContent = '0';
            list.innerHTML = '<div class="tiny">Chưa có dữ liệu</div>';
            return;
        }

        const total = (s.stats && s.stats.totalMinutes) ? s.stats.totalMinutes : 0;
        const count = (s.stats && s.stats.sessionsCompleted) ? s.stats.sessionsCompleted : 0;
        const tasksDone = s.tasks ? s.tasks.filter(t => t.isCompleted).length : 0;

        statTotal.textContent = formatDaysHoursMinutes(total);
        statSessions.textContent = String(count);
        statTasks.textContent = String(tasksDone);

        list.innerHTML = '';
        const sessions = Array.isArray(s.sessions) ? s.sessions : [];
        if (sessions.length === 0) {
            list.innerHTML = '<div class="tiny">Chưa có phiên nào</div>';
            return;
        }
        sessions.forEach(sess => {
            const row = document.createElement('div');
            row.className = 'hist-item';
            const content = document.createElement('div');
            const date = sess.dateISO ? new Date(sess.dateISO) : new Date();
            const dur = (sess.durationMinutes != null) ? sess.durationMinutes : (sess.workMinutes || 0);
            const metaHTML = `<div class="hist-meta">${date.toLocaleString()} · ${dur}' · Mode ${sess.mode || ''}</div>`;
            let noteHTML = '';
            if (sess.note) {
                noteHTML = `<div>${escapeHTML(sess.note)}</div>`;
            } else if (data?.settings?.enableSessionNotes !== false) {
                noteHTML = `<div><span class="tiny">(chưa có ghi chú)</span></div>`;
            }
            content.innerHTML = metaHTML + noteHTML;
            row.appendChild(content);
            list.appendChild(row);
        });
    }
    function renderGeneralNotes(){
        const listEl = $('#generalNotesList');
        if (!listEl) return;
        const s = getCurrentSubtopic();
        if (!s) { listEl.innerHTML = '<div class="tiny">Vui lòng chọn một chủ đề con.</div>'; return; }
        s.generalNotes = s.generalNotes || [];
        if (s.generalNotes.length === 0) { listEl.innerHTML = '<div class="tiny">Chưa có ghi chú.</div>'; return; }
        listEl.innerHTML = '';
        s.generalNotes.forEach(note => {
            const item = document.createElement('div'); item.className = 'note-item';
            const content = document.createElement('div'); content.className = 'note-content'; content.textContent = typeof note === 'string' ? note : (note.text || '');
            const meta = document.createElement('div'); meta.className = 'note-meta'; meta.textContent = note.createdAt ? new Date(note.createdAt).toLocaleString() : '';
            const actions = document.createElement('div');
            const delBtn = document.createElement('button'); delBtn.className = 'btn small danger'; delBtn.textContent = 'Xóa';
            delBtn.onclick = async (e)=>{
                e.stopPropagation();
                const s2 = getCurrentSubtopic(); if (!s2) return;
                s2.generalNotes = (s2.generalNotes || []).filter(x => (x.id || x) !== (note.id || note));
                await saveData();
                renderGeneralNotes();
            };
            actions.appendChild(delBtn);
            const wrap = document.createElement('div'); wrap.className = 'note-content-wrapper'; wrap.append(content, meta);
            item.append(wrap, actions);
            listEl.appendChild(item);
        });
    }
    function renderMethods() {
        const container = document.querySelector('#view-methods .methods-container');
        if (!container) return;
        container.innerHTML = '';

        const s = getCurrentSubtopic();
        if (!s) {
            container.innerHTML = '<p class="tiny" style="opacity:0.7;">Vui lòng chọn một Chủ đề con để xem Kho Tri Thức.</p>';
            return;
        }

        const methods = Array.isArray(s.methods) ? s.methods : [];

        if (methods.length === 0) {
            container.innerHTML = '<p class="tiny" style="opacity:0.7;">Chưa có tri thức nào trong Chủ đề con này.</p>';
            return;
        }

        methods.forEach(method => {
            const details = document.createElement('div');
            details.className = 'method-item';
            details.dataset.methodId = method.id;

            const summary = document.createElement('div');

            // Mở rộng vùng nhấn bằng cách đặt tiêu đề trong span riêng
            const titleSpan = document.createElement('span');
            titleSpan.className = 'method-title';
            titleSpan.textContent = method.title || 'Chưa có tiêu đề';
            // Nhấp vào tiêu đề để mở thẻ (không toggle)
            titleSpan.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                const contentDiv = details.querySelector('.method-content');
                if (!contentDiv) return;
                const isOpening = contentDiv.hidden;
                container.querySelectorAll('.method-item .method-content').forEach(el => { el.hidden = true; });
                contentDiv.hidden = !isOpening;
            });

            // Actions hiển thị ở cuối thanh tiêu đề (summary)
            const actions = document.createElement('div');
            actions.className = 'topic-actions';
            const btnEdit = document.createElement('button');
            btnEdit.className = 'btn small ghost method-edit';
            btnEdit.textContent = 'Sửa';
            btnEdit.dataset.id = method.id;
            const btnDel = document.createElement('button');
            btnDel.className = 'btn small danger method-delete';
            btnDel.textContent = 'Xóa';
            btnDel.dataset.id = method.id;
            actions.append(btnEdit, btnDel);
            summary.append(titleSpan, actions);

            const contentDiv = document.createElement('div');
            contentDiv.className = 'method-content';
            contentDiv.innerHTML = method.content || '';
            contentDiv.hidden = true;


            details.append(summary, contentDiv);
            container.appendChild(details);

            // Click anywhere on the card to open (except controls)
            details.addEventListener('click', (e) => {
                const t = e.target;
                if (!t) return;
                if (t.closest('button') || t.closest('a') || t.closest('.color-picker-wrapper') || t.closest('.color-palette')) return;
                const isOpening = contentDiv.hidden;
                container.querySelectorAll('.method-item .method-content').forEach(el => { el.hidden = true; });
                contentDiv.hidden = !isOpening;
            });
        });

        // Tự động đóng các thẻ khác (accordion)
        const allMethodItems = container.querySelectorAll('.method-item');
        allMethodItems.forEach(item => {
            item.addEventListener('toggle', () => {
                if (item.open) {
                    allMethodItems.forEach(other => { if (other !== item) other.open = false; });
                }
            });
        });

        // === START: KÍCH HOẠT KÉO-THẢ CHO KHO TRI THỨC ===
        if (window.Sortable) {
            new Sortable(container, {
                animation: 150,
                draggable: '.method-item', // Xác định phần tử có thể kéo
                onEnd: async function (evt) {
                    if (evt.oldIndex === evt.newIndex) return; // Không thay đổi nếu vị trí cũ và mới như nhau

                    const subtopic = getCurrentSubtopic();
                    if (!subtopic || !Array.isArray(subtopic.methods)) return;

                    // Cập nhật lại thứ tự trong mảng dữ liệu
                    const movedItem = subtopic.methods.splice(evt.oldIndex, 1)[0];
                    subtopic.methods.splice(evt.newIndex, 0, movedItem);

                    // Lưu lại thay đổi
                    await saveData();
                    // Không cần render lại vì thư viện đã tự cập nhật giao diện
                }
            });
        }
        // === END: KÍCH HOẠT KÉO-THẢ CHO KHO TRI THỨC ===
    }
    function addGeneralNote(){
        showInputModal('Thêm ghi chú', async (text) => {
            if (!text) return;
            const s = getCurrentSubtopic();
        if (!s) { toast('Chọn một chủ đề con trước.'); return; }
            s.generalNotes = s.generalNotes || [];
            s.generalNotes.unshift({ id: uid('gn'), text, createdAt: todayISO() });
            await saveData();
            renderGeneralNotes();
        }, '');
    }
    async function summarizeNotes(){
        const s = getCurrentSubtopic();
        if (!s) { toast('Chọn chủ đề con trước.'); return; }
        const notes = (s.generalNotes || []).map(n => (typeof n === 'string' ? n : (n.text||''))).filter(Boolean);
        if (notes.length === 0) { toast('Chưa có ghi chú để tóm tắt.'); return; }
        const btn = $('#btnSummarize');
        if (btn) { btn.disabled = true; btn.innerHTML = '<div class="spinner"></div>'; }
        try {
            const prompt = `Tóm tắt các ghi chú sau theo gạch đầu dòng, ngắn gọn, rõ ràng:\n\n${notes.join('\n- ')}`;
            const result = await callGeminiAPI(prompt);
            if (!s.summaries) s.summaries = [];
            s.summaries.unshift({ id: uid('sum'), content: result || '(Không tạo được tóm tắt)', createdAt: todayISO() });
            await saveData();
            renderSummaries();
        } catch (e) {
            console.error(e);
            toast('Tóm tắt thất bại.');
        } finally {
            if (btn) { btn.disabled = false; btn.textContent = 'Tóm tắt'; }
        }
    }
    function renderSummaries() {
        const listEl = $('#summariesList');
        if (!listEl) return;
        const s = getCurrentSubtopic();
        if (!s) { listEl.innerHTML = '<div class="tiny">Vui lòng chọn một chủ đề con để xem tóm tắt.</div>'; return; }
        listEl.innerHTML = '';
        if (!s.summaries || s.summaries.length === 0) { listEl.innerHTML = '<div class="tiny">Chưa có tóm tắt nào.</div>'; return; }
        s.summaries.forEach(sum => {
            const item = document.createElement('div'); item.className = 'note-item';
            const contentWrapper = document.createElement('div'); contentWrapper.className = 'note-content-wrapper';
            const sumContent = document.createElement('div'); sumContent.className = 'note-content'; sumContent.textContent = sum.content;
            const sumMeta = document.createElement('div'); sumMeta.className = 'note-meta'; sumMeta.textContent = new Date(sum.createdAt).toLocaleString();
            contentWrapper.append(sumContent, sumMeta);
            const actions = document.createElement('div');
            const expBtn = document.createElement('button'); expBtn.className = 'btn small'; expBtn.textContent = 'Xuất'; expBtn.onclick = (e)=>{ e.stopPropagation(); exportSummary(sum); };
            const delBtn = document.createElement('button'); delBtn.className = 'btn small danger'; delBtn.textContent = 'Xóa'; delBtn.onclick = (e)=>{ e.stopPropagation(); deleteSummary(sum.id); };
            actions.append(expBtn, delBtn);
            item.append(contentWrapper, actions);
            item.addEventListener('click', ()=> sumContent.classList.toggle('expanded'));
            listEl.appendChild(item);
        });
    }
      function loadEditingPresetFields(){
          const s = data.settings;
          const d = s.durations;
          const pomodoroWrap = $('#settings-pomodoro');
          const flowWrap = $('#settings-flowtime');
          if (pomodoroWrap && flowWrap) {
            const isFlow = (editingPreset === 'C');
            pomodoroWrap.classList.toggle('hidden', isFlow);
            flowWrap.classList.toggle('hidden', !isFlow);
          }
          if(editingPreset === 'A'){
              $('#set_work').value = d.A_work;
              if ($('#set_winddown')) $('#set_winddown').value = d.A_winddown ?? 0;
              $('#set_short').value = d.A_short;
              $('#set_long').value = d.A_long;
              $('#set_cycles').value = s.cyclesA;
              $('#set_interval').value = s.longBreakIntervalA;
          } else if (editingPreset === 'B') {
              $('#set_work').value = d.B_work;
              if ($('#set_winddown')) $('#set_winddown').value = d.B_winddown ?? 0;
              $('#set_short').value = d.B_short;
              $('#set_long').value = d.B_long;
              $('#set_cycles').value = s.cyclesB;
              $('#set_interval').value = s.longBreakIntervalB;
          } else if (editingPreset === 'C') {
              const ratioInput = $('#set_flowRatio');
              if (ratioInput) ratioInput.value = s.flowtimeBreakRatio ?? 5;
          }
      }
      function highlightPresetSelector(){
          $$('#timerPresetSelector button').forEach(btn=>{
              const isActive = btn.dataset.presetTarget === editingPreset;
              btn.classList.toggle('acc', isActive);
              btn.classList.toggle('ghost', !isActive);
          });
      }
      function openSettings(){
          const s = data.settings;
          editingPreset = s.preset;
          $('#set_apiKey').value = s.apiKey || '';
          loadEditingPresetFields();
          highlightPresetSelector();
          $('#set_volume').value=s.volume ?? 0.8;
          $('#set_theme').value=s.soundTheme || 'beep';
          const customToggle = $('#set_useCustomSounds');
          const customContainer = $('#customSoundsContainer');
          if (customToggle) {
              customToggle.checked = !!s.useCustomSounds;
              if (customContainer) customContainer.classList.toggle('hidden', !customToggle.checked);
          }
          // THAY ĐỔI: Cập nhật giá trị dropdown
          $('#set_theme_color').value = s.theme || 'default';
          const activeUrl = getActiveYoutubeUrl();
          $('#set_youtubeUrl').value = activeUrl || '';
          const initialVideoId = extractYouTubeID(activeUrl);
          $('#btnToggleYtSound').disabled = !initialVideoId;
          if ($('#ytUrlFeedback')) {
              $('#ytUrlFeedback').textContent = '';
          }
          $('#ytSoundVolume').value = s.youtubeVolume || 80;
          $('#set_ytThumbAsBg').checked = !!s.useYtThumbnailAsBg;
          $('#set_panelOpacity').value = s.panelOpacity || 0.85;
          if ($('#set_language')) { $('#set_language').value = s.language || (localStorage.getItem('lang') || 'vi'); }
          if ($('#set_backgroundMode')) { $('#set_backgroundMode').value = s.backgroundMode || 'cover'; }
          
          if ($('#set_autoStartNext')) { $('#set_autoStartNext').checked = !!s.autoStartNext; }
          if ($('#set_enableWinddown')) { $('#set_enableWinddown').checked = (s.enableWinddown !== false); }
          if ($('#set_enableSessionNotes')) { $('#set_enableSessionNotes').checked = (s.enableSessionNotes !== false); }
          if ($('#set_backupDays')) { $('#set_backupDays').value = s.backupDaysToKeep || 7; }
        const backupListEl = $('#backupList');
        if (backupListEl) {
            storageManager.getBackupList().then(backups => {
                backupListEl.innerHTML = '<option value="">-- Chọn ngày để phục hồi --</option>';
                if (backups && backups.length > 0) {
                    backups.forEach(backup => {
                        const option = document.createElement('option');
                        option.value = backup.date;
                        option.textContent = `Bản sao lưu ngày: ${new Date(backup.date).toLocaleDateString('vi-VN')}`;
                        backupListEl.appendChild(option);
                    });
                } else {
                    backupListEl.innerHTML = '<option value="">Không có bản sao lưu nào</option>';
                }
            });
        }
        $('#modalSettings').classList.add('show');
        try { trapFocus($('#modalSettings')); } catch(_) {}
    }
    function closeSettings(){ $('#modalSettings').classList.remove('show'); try { releaseFocus(); } catch(_) {} }
    async function setDefaults(){
        data.settings.durations={A_work:25,A_short:5,A_long:15,A_winddown:2,B_work:50,B_short:10,B_long:30,B_winddown:5};
        data.settings.cyclesA=4;
        data.settings.longBreakIntervalA=4;
        data.settings.cyclesB=4;
        data.settings.longBreakIntervalB=4;
        data.settings.flowtimeBreakRatio=5;
          data.settings.preset='A';
          data.settings.volume=0.8;
          data.settings.soundTheme='beep';
          data.settings.useCustomSounds = false;
          await saveData(); openSettings(); toast('Đã khôi phục mặc định'); }
      async function saveSettings(){
          const s = data.settings;
          s.apiKey = $('#set_apiKey').value.trim();
          const d = s.durations;
          if(editingPreset === 'A'){
              d.A_work = clampInt($('#set_work').value,1,999);
              d.A_winddown = clampInt($('#set_winddown').value,0,999);
              d.A_short = clampInt($('#set_short').value,1,999);
              d.A_long = clampInt($('#set_long').value,1,999);
              s.cyclesA = clampInt($('#set_cycles').value,1,12);
              s.longBreakIntervalA = clampInt($('#set_interval').value,2,12);
          } else if (editingPreset === 'B') {
              d.B_work = clampInt($('#set_work').value,1,999);
              d.B_winddown = clampInt($('#set_winddown').value,0,999);
              d.B_short = clampInt($('#set_short').value,1,999);
              d.B_long = clampInt($('#set_long').value,1,999);
              s.cyclesB = clampInt($('#set_cycles').value,1,12);
              s.longBreakIntervalB = clampInt($('#set_interval').value,2,12);
          } else if (editingPreset === 'C') {
              const ratioInput = $('#set_flowRatio');
              if (ratioInput) s.flowtimeBreakRatio = clampInt(ratioInput.value, 1, 20);
          }
          s.volume = clampFloat($('#set_volume').value,0,1,0.8);
          s.soundTheme = $('#set_theme').value==='chime' ? 'chime':'beep';
          // THAY ĐỔI: Lưu giá trị theme
          s.theme = $('#set_theme_color').value;
          s.language = ($('#set_language') && $('#set_language').value) || s.language;
          s.panelOpacity = parseFloat($('#set_panelOpacity').value) || 0.85;
          if ($('#set_backgroundMode')) { s.backgroundMode = $('#set_backgroundMode').value; }
          s.autoStartNext = !!($('#set_autoStartNext') && $('#set_autoStartNext').checked);
          s.enableWinddown = !!($('#set_enableWinddown') && $('#set_enableWinddown').checked);
          s.enableSessionNotes = !!($('#set_enableSessionNotes') && $('#set_enableSessionNotes').checked);
          if ($('#set_useCustomSounds')) { s.useCustomSounds = !!$('#set_useCustomSounds').checked; }
          if ($('#set_backupDays')) { s.backupDaysToKeep = clampInt($('#set_backupDays').value, 1, 30); }

          // Bổ sung: Nếu chọn theme sáng, luôn tắt thumbnail YouTube làm nền
          if (s.theme === 'light' || s.theme === 'pastel') {
              s.useYtThumbnailAsBg = false;
              // Nếu nền hiện tại là thumbnail YouTube, bỏ nền để giữ nền gốc của theme sáng
              if (typeof s.customBg === 'string' && s.customBg.includes('img.youtube.com/vi/')) {
                  s.customBg = '';
              }
          } else {
              // Ngược lại, với theme tối thì bật dùng thumbnail YouTube (nếu có link)
              s.useYtThumbnailAsBg = true;
          }

          const newYtUrl = $('#set_youtubeUrl').value.trim();
          s.useYtThumbnailAsBg = $('#set_ytThumbAsBg').checked;
          s.youtubeVolume = parseInt($('#ytSoundVolume').value, 10);
          // Ghi nhận URL mới cho phiên nhưng KHÔNG đụng đến player ở đây để tránh dừng nhạc
          sessionYoutubeUrl = newYtUrl;
          // Cập nhật âm lượng trực tiếp, không cue lại video
          try {
              if (!IS_FILE_PROTOCOL) {
                  if (ytPlayer && ytPlayer.setVolume) ytPlayer.setVolume(s.youtubeVolume);
              } else {
                  // Fallback: gửi lệnh setVolume qua postMessage nếu đang dùng iframe nhúng
                  try { fallbackPostMessage('setVolume', [s.youtubeVolume]); } catch(_) {}
              }
          } catch(_) {}

          await saveData();
          applyTheme();
          applyCustomBg();
          applyPanelOpacity();
          updatePresetButtonsText();
          timer.setPreset(s.preset, {silent:true});

          // Không can thiệp trạng thái đang phát: tránh cue/pause lại khi nhấn Lưu

          closeSettings();
          toast('Đã lưu cài đặt');
      }
    function clampInt(v,min,max){ v=parseInt(v||0,10); if(isNaN(v)) v=min; return Math.max(min, Math.min(max, v)); }
    function clampFloat(v,min,max,def){ v=parseFloat(v); if(Number.isNaN(v)) v=def; return Math.max(min, Math.min(max, v)); }
    const dbPromise = new Promise((resolve, reject) => {
        const req = indexedDB.open('pomodoro_files', 1);
        req.onupgradeneeded = (e) => e.target.result.createObjectStore('files');
        req.onsuccess = (e) => resolve(e.target.result);
        req.onerror = (e) => reject(e);
    });
    const fileCache = {};
    function handleFileUpload(file, callback) {
        if (!file) return;
        dbPromise.then(db => {
            const id = uid('file');
            const tx = db.transaction('files', 'readwrite');
            tx.objectStore('files').put(file, id);
            tx.oncomplete = () => callback(id);
            tx.onerror = () => toast("Lỗi lưu file.");
        });
    }
    function getStoredFileUrl(id){
        if (!id) return Promise.resolve('');
        if (fileCache[id]) return Promise.resolve(fileCache[id]);
        return dbPromise.then(db => new Promise((resolve) => {
            const tx = db.transaction('files', 'readonly');
            const req = tx.objectStore('files').get(id);
            req.onsuccess = (e) => {
                const file = e.target.result;
                if (file) {
                    const url = URL.createObjectURL(file);
                    fileCache[id] = url;
                    resolve(url);
                } else resolve('');
            };
            req.onerror = () => resolve('');
        }));
    }
    function applyCustomBg() {
        const s = data.settings;
        const ref = s.customBg;
        const theme = s.theme;
        const themeHasBg = ['lofi', 'space'].includes(theme);
        const isLightTheme = (theme === 'light' || theme === 'pastel');

        // Áp dụng chế độ hiển thị nền
        const bgMode = s.backgroundMode || 'cover';
        document.body.style.backgroundSize = bgMode;
        document.body.style.backgroundRepeat = (bgMode === 'auto') ? 'repeat' : 'no-repeat';

        const clearInlineBgFallback = () => { try { document.body.style.backgroundImage = ''; } catch(_) {} };

        if (ref) {
            const urlPromise = (ref.startsWith('data:') || ref.startsWith('http') || ref.startsWith('blob:'))
                ? Promise.resolve(ref)
                : getStoredFileUrl(ref);
            
            urlPromise.then(url => {
                if (url) {
                    document.body.style.setProperty('--bg-image', `url(${url})`);
                } else {
                    document.body.style.setProperty('--bg-image', isLightTheme ? 'none' : '');
                }
                clearInlineBgFallback();
            });
        } else if (!themeHasBg) {
            if (isLightTheme) {
                // Light/pastel: không dùng nền tối
                document.body.style.setProperty('--bg-image', 'none');
                clearInlineBgFallback();
            } else {
                // Dark/default fallback
                document.body.style.setProperty('--bg-image', 'radial-gradient(1200px 800px at 10% -10%, #20285b 0%, #0f1222 50%, #0b0e1a 100%)');
            }
        } else {
            // Let the CSS for the theme handle the background
            document.body.style.removeProperty('--bg-image');
            clearInlineBgFallback();
        }
    }
    function applyPanelOpacity() { document.documentElement.style.setProperty('--panel-opacity', data.settings.panelOpacity); }
      function renderDashboard(){
          const stats = data.topics.flatMap(t => t.subtopics.map(s => ({ topic: t.name, subtopic: s.name, m: s.stats.totalMinutes || 0, c: s.stats.sessionsCompleted || 0, t: s.stats.tasksCompleted || 0 })));
          const totalM = stats.reduce((a, b) => a + b.m, 0);
          const totalC = stats.reduce((a, b) => a + b.c, 0);
          const totalT = stats.reduce((a, b) => a + b.t, 0);

        let tableHTML = `<p class="tiny"><strong>Tổng thời gian:</strong> ${formatDaysHoursMinutes(totalM)} | <strong>Tổng phiên:</strong> ${totalC} | <strong>Tổng nhiệm vụ:</strong> ${totalT}</p>
        <table class="dashboard-table">
            <thead><tr><th>Chủ đề</th><th>Chủ đề con</th><th>Thời gian</th><th>Phiên</th><th>Nhiệm vụ</th></tr></thead>
            <tbody>`;

          stats.forEach(item => {
            tableHTML += `<tr><td>${escapeHTML(item.topic)}</td><td>${escapeHTML(item.subtopic)}</td><td>${formatDaysHoursMinutes(item.m)}</td><td>${item.c}</td><td>${item.t}</td></tr>`;
        });

        tableHTML += '</tbody></table>';
        const contentEl = $('#dashboardContent');
        if (contentEl) contentEl.innerHTML = tableHTML;
    }
    function getMilestones() {
        return [
            // === GIAI ĐOẠN ĐẦU: XÂY DỰNG THÓI QUEN ===
            {
                hours: 5,
                title: "Gửi bạn, 5 giờ đầu tiên (Khởi động)",
                message: "Năm giờ tập trung! Bạn đã vượt qua rào cản lớn nhất: sự trì hoãn. Mỗi phút bạn dành ra đều là một lời khẳng định cho mục tiêu của mình. Hãy giữ vững ngọn lửa này!"
            },
            {
                hours: 20,
                title: "Gửi bạn, 20 giờ (Nền tảng)",
                message: "Chúc mừng bạn đã làm được điều khó nhất: Bắt đầu và duy trì.\n\n20 giờ không chỉ là thời gian, đó là 20 giờ bạn đã chiến thắng sự xao nhãng. Bạn đang xây dựng một nền tảng vững chắc cho sự kỷ luật. Hãy tự hào về khởi đầu này."
            },
            {
                hours: 50,
                title: "Gửi bạn, 50 giờ (Động lực)",
                message: "50 giờ tập trung! Thói quen của bạn đang tạo ra động lực. Sự nhất quán nhỏ bé mỗi ngày đang cộng hưởng thành những bước tiến lớn. Bạn đang đi đúng hướng, hãy tiếp tục phát huy."
            },

            // === GIAI ĐOẠN GIỮA: CAM KẾT VÀ BỀN BỈ ===
            {
                hours: 100,
                title: "Gửi bạn, 100 giờ cống hiến (Cam kết)",
                message: "100 giờ! Đây không còn là một thử nghiệm nữa, mà là một sự đầu tư nghiêm túc cho mục tiêu của bạn.\n\nHãy dành một chút thời gian để nhìn lại: 100 giờ tập trung này đã giúp bạn tiến xa đến đâu? Năng lượng bạn bỏ ra đang định hình nên kết quả."
            },
            {
                hours: 250,
                title: "Gửi bạn, 250 giờ (Bền bỉ)",
                message: "250 giờ là minh chứng cho sự bền bỉ đáng kinh ngạc. Bạn đã đối mặt với những ngày khó khăn, những lúc mất tập trung, nhưng bạn vẫn quay trở lại. Sức mạnh thực sự nằm ở chính sự kiên trì này."
            },
            {
                hours: 500,
                title: "Gửi bạn, 500 giờ (Chuyên tâm)",
                message: "Nửa nghìn giờ tập trung. Bạn đã dành một khoảng thời gian đáng kể để theo đuổi điều quan trọng với mình. Mức độ chuyên tâm này chắc chắn đang tạo ra những kết quả sâu sắc và khác biệt. Thật đáng ngưỡng mộ."
            },

            // === GIAI ĐOẠN NÂNG CAO: CHUYỂN HÓA VÀ DI SẢN ===
            {
                hours: 1000,
                title: "Gửi bạn, 1.000 giờ (Chuyển hóa)",
                message: "Chào mừng đến Câu lạc bộ 1000 giờ.\n\nCon số này không chỉ đo lường thời gian, nó đại diện cho sự chuyển hóa. Sự tập trung đã trở thành một phần con người bạn, một 'siêu năng lực' bạn có thể triệu hồi. Hành trình của bạn thực sự truyền cảm hứng."
            },
            {
                hours: 5000,
                title: "Gửi bạn, 5.000+ giờ (Di sản)",
                message: "5.000 giờ tập trung có chủ đích. Đây là một thành tựu mà rất ít người đạt được.\n\nTại cột mốc này, câu hỏi không còn là 'Làm thế nào để tập trung?', mà là 'Sự tập trung này sẽ được dùng để tạo ra giá trị gì?'. Bạn không chỉ làm việc, bạn đang tạo ra di sản."
            }
        ].sort((a, b) => b.hours - a.hours); // Sắp xếp giảm dần để dễ xử lý
    }
    async function checkAndShowMilestones() {
        if (!data || !data.settings) return;
        if (!Array.isArray(data.settings.achievedMilestones)) data.settings.achievedMilestones = [];
        const totalMinutes = data.topics.reduce((total, topic) => {
            return total + topic.subtopics.reduce((subTotal, subtopic) => {
                return subTotal + (subtopic.stats.totalMinutes || 0);
            }, 0);
        }, 0);
        const totalHours = totalMinutes / 60;
        const milestones = getMilestones();
        const achieved = Array.isArray(data.settings.achievedMilestones) ? data.settings.achievedMilestones : [];
        const eligible = milestones.filter(m => totalHours >= m.hours && !achieved.includes(m.hours));
        if (eligible.length === 0) return false;
        const target = eligible.reduce((best, m) => (best && best.hours > m.hours ? best : m), null);
        if (!target) return false;
        $('#milestoneTitle').textContent = target.title;
        $('#milestoneMessage').textContent = target.message;
        $('#modalMilestone').classList.add('show');
        try { trapFocus($('#modalMilestone')); } catch(_) {}
        data.settings.achievedMilestones.push(target.hours);
        await saveData();
        return true;
    }
    async function seedAchievedMilestones() {
        if (!data || !data.settings) return;
        if (!Array.isArray(data.settings.achievedMilestones)) {
            data.settings.achievedMilestones = [];
            await saveData();
        }
    }
    async function handleSendMessage() {
        const btn = $('#btnSendMessage');
        const input = $('#chatInput');
        const query = input.value.trim();
        const subtopic = getCurrentSubtopic();
        if (!query) return;
        if (!subtopic) { toast(t('timer.selectSubtopicPrompt')); return; }
        input.value = '';
        btn.disabled = true;
        btn.innerHTML = '<div class="spinner"></div>';
        subtopic.chatHistory.push({ role: 'user', text: query });
        renderChat();
        const response = await callGeminiAPI(query);
        if (response) {
            subtopic.chatHistory.push({ role: 'model', text: response });
            await saveData();
            renderChat();
        }
        btn.disabled = false;
        btn.innerHTML = 'Gửi';
    }
    function renderChat() {
        const s = getCurrentSubtopic();
        const messagesEl = $('#chatMessages');
        const chatInput = $('#chatInput');
        const sendBtn = $('#btnSendMessage');
        if (!messagesEl || !chatInput || !sendBtn) return;
        if (!s) {
            messagesEl.innerHTML = '<div class="tiny">Chọn chủ đề con để bắt đầu chat.</div>';
            chatInput.disabled = true; sendBtn.disabled = true;
            return;
        }
        chatInput.disabled = false; sendBtn.disabled = false;
        messagesEl.innerHTML = '';
        if (!s.chatHistory || s.chatHistory.length === 0) {
            messagesEl.innerHTML = '<div class="tiny">Chưa có tin nhắn nào.</div>';
            return;
        }
        s.chatHistory.forEach(msg => {
            const msgEl = document.createElement('div');
            msgEl.className = `chat-msg ${msg.role}`;
            msgEl.textContent = msg.text;
            messagesEl.appendChild(msgEl);
        });
        messagesEl.scrollTop = messagesEl.scrollHeight;
    }
    async function handleSummarizeNote() {
        const btn = $('#btnSummarizeNote');
        const noteTextEl = $('#noteText');
        const noteText = noteTextEl.value.trim();
        const subtopic = getCurrentSubtopic();
        if (!noteText) { toast("Vui lòng nhập ghi chú trước khi tóm tắt."); return; }
        const originalContent = btn.innerHTML;
        btn.innerHTML = '<div class="spinner"></div>'; btn.disabled = true;
        const prompt = `Dựa vào thông tin sau:\n- Chủ đề: "${subtopic?.name || 'không rõ'}"\n- Ghi chú của người dùng sau một phiên làm việc: "${noteText}"\n\nHãy tạo một bản tóm tắt ngắn gọn về những gì đã làm và đề xuất một bước hợp lý tiếp theo. Định dạng câu trả lời như sau:\n\n---\n**✨ Tóm tắt AI:**\n[Tóm tắt ở đây]\n\n**🚀 Gợi ý tiếp theo:**\n[Gợi ý ở đây]`;
        const result = await callGeminiAPI(prompt);
        if (result) {
            noteTextEl.value += `\n\n${result}`;
        }
        btn.innerHTML = originalContent; btn.disabled = false;
    }
    function clearChat() {
        const s = getCurrentSubtopic();
        if (!s) { toast(t('timer.selectSubtopicPrompt')); return; }
        showConfirmModal('Xác nhận xóa', 'Bạn có chắc muốn xóa toàn bộ lịch sử chat của chủ đề con này?', async (ok) => {
            if (ok) {
                s.chatHistory = [];
                await saveData();
                renderChat();
                toast("Đã xóa lịch sử chat.");
            }
        });
    }
    let ytPlayer;
    let ytUserPaused = false;
    let ytFallbackFrame = null;
    let ytFallbackIsPlaying = false;
    function buildFallbackSrc(videoId, { autoplay=1, mute=1 }={}){
        const params = new URLSearchParams({
            autoplay: String(autoplay),
            mute: String(mute),
            controls: '0',
            playsinline: '1',
            loop: '1',
            playlist: videoId,
            enablejsapi: '1',
            origin: 'https://www.youtube.com'
        }).toString();
        return `https://www.youtube.com/embed/${videoId}?${params}`;
    }
    function ensureFallbackFrame(){
        const cont = document.getElementById('youtube-player-container');
        if (!cont) return null;
        if (ytFallbackFrame && ytFallbackFrame.isConnected) return ytFallbackFrame;
        const ifr = document.createElement('iframe');
        ifr.id = 'yt-fallback';
        ifr.width = '1'; ifr.height = '1';
        ifr.style.position = 'absolute'; ifr.style.top='-9999px'; ifr.style.left='-9999px';
        ifr.allow = 'autoplay; encrypted-media; picture-in-picture';
        cont.innerHTML = '';
        cont.appendChild(ifr);
        ytFallbackFrame = ifr;
        return ifr;
    }
    function fallbackLoadVideo(videoId, {autoplay=1, mute=1}={}){
        const cont = document.getElementById('youtube-player-container');
        if (!cont) return;
        cont.innerHTML = '';
        const ifr = document.createElement('iframe');
        ifr.id = 'yt-fallback';
        ifr.width = '1';
        ifr.height = '1';
        ifr.style.position = 'absolute';
        ifr.style.top='-9999px';
        ifr.style.left='-9999px';
        ifr.allow = 'autoplay; encrypted-media; picture-in-picture';
        ifr.src = buildFallbackSrc(videoId, {autoplay, mute});
        cont.appendChild(ifr);
        ytFallbackFrame = ifr;
        ytFallbackIsPlaying = !!autoplay;
        try { 
            const btn = document.getElementById('btnToggleYtSound'); 
            if (btn) btn.textContent = ytFallbackIsPlaying ? '⏸️' : '▶️'; 
        } catch(_) {}
    }
    function fallbackPostMessage(func, args=[]) {
        try {
            if (!ytFallbackFrame || !ytFallbackFrame.contentWindow) return;
            ytFallbackFrame.contentWindow.postMessage(JSON.stringify({ event:'command', func, args }), 'https://www.youtube.com');
        } catch(_) {}
    }
    function fallbackPlay(){ fallbackPostMessage('playVideo'); }
    function fallbackStop(){
        try {
            if (ytFallbackFrame) {
                ytFallbackFrame.src = 'about:blank';
                ytFallbackIsPlaying = false;
            }
        } catch(_) {}
    }
    function fallbackPause(){ fallbackStop(); }
    function fallbackUnMute(){ fallbackPostMessage('unMute'); }
    function fallbackMute(){ fallbackPostMessage('mute'); }
    window.onYouTubeIframeAPIReady = function() {
        if (IS_FILE_PROTOCOL) {
            try { window.__ytApiWatchdog && window.__ytApiWatchdog.cancel(); } catch(_) {}
            return;
        }
        const opts = {
            height: '1',
            width: '1',
            playerVars: { autoplay: 0, controls: 0, playsinline: 1 },
            events: { onReady: onPlayerReady, onStateChange: onPlayerStateChange },
            host: 'https://www.youtube.com'
        };
        if (window.location.protocol === 'http:' || window.location.protocol === 'https:') {
            opts.origin = window.location.origin;
        }
        ytPlayer = new YT.Player('youtube-player-container', opts);
        try { window.__ytApiWatchdog && window.__ytApiWatchdog.cancel(); const fb = document.getElementById('ytUrlFeedback'); if (fb) { fb.textContent=''; } } catch(_) {}
    };

    let _ytPrimed = false;
    let _ytUnlocked = false;
    try { _ytUnlocked = localStorage.getItem('sound_unlocked') === '1'; } catch(_) {}
    function showSoundPermission() {
        const bar = document.getElementById('soundPermissionBar');
        if (!bar) return;
        if (_ytUnlocked) { bar.classList.remove('show'); return; }
        bar.classList.add('show');
    }
    function hideSoundPermission() {
        const bar = document.getElementById('soundPermissionBar');
        if (!bar) return;
        bar.classList.remove('show');
    }
    function unlockAudioChain() {
        try { if (AUDIO_CTX && typeof AUDIO_CTX.resume === 'function') AUDIO_CTX.resume(); } catch(_) {}
        try {
            if (IS_FILE_PROTOCOL) {
                fallbackUnMute();
                fallbackPlay();
            } else if (ytPlayer && ytPlayer.unMute) {
                ytPlayer.unMute();
                ytPlayer.playVideo();
            }
        } catch(_) {}
        _ytUnlocked = true;
        try { localStorage.setItem('sound_unlocked','1'); } catch(_) {}
        hideSoundPermission();
        toast('Âm thanh đã được bật!');
    }
    function onPlayerReady(event) {
        try {
            const iframe = ytPlayer && ytPlayer.getIframe ? ytPlayer.getIframe() : null;
            if (iframe) {
                iframe.setAttribute('allow', 'autoplay; encrypted-media; picture-in-picture');
            }
        } catch (_) {}
        try { if (ytPlayer && ytPlayer.setVolume) ytPlayer.setVolume((data && data.settings && data.settings.youtubeVolume) || 80); } catch(_) {}
        // Prime muted autoplay like 4.html so music starts silently and waits for user to enable sound
        try {
            const hasVid = getActiveVideoId && getActiveVideoId();
            if (hasVid && ytPlayer && ytPlayer.mute && ytPlayer.playVideo) {
                ytPlayer.mute();
                ytPlayer.playVideo();
                _ytPrimed = true;
                const unlock = () => {
                    if (_ytUnlocked) return;
                    try { unlockAudioChain(); } catch(_) {}
                    window.removeEventListener('pointerdown', unlock, true);
                    window.removeEventListener('keydown', unlock, true);
                };
                window.addEventListener('pointerdown', unlock, true);
                window.addEventListener('keydown', unlock, true);
                showSoundPermission();
            }
        } catch(_) {}
        updateYouTubePlayer();
    }
    function onPlayerStateChange(event) {
        const btn = $('#btnToggleYtSound');
        if (event.data == YT.PlayerState.PLAYING) {
            btn.textContent = '⏸️';
            hideSoundPermission();
        } else {
            btn.textContent = '▶️';
        }
        if (event.data === YT.PlayerState.ENDED) {
            if (!ytUserPaused) ytPlayer.playVideo();
        }
    }
    async function ytFadeTo(target, ms=250) {
        try {
            if (!ytPlayer || !ytPlayer.getVolume || !ytPlayer.setVolume) return;
            ytPlayer.unMute();
            const start = ytPlayer.getVolume();
            const diff = target - start;
            if (Math.abs(diff) < 1 || ms <= 0) { ytPlayer.setVolume(target); return; }
            const t0 = performance.now();
            await new Promise(res => {
                const step = (t) => {
                    const p = Math.min(1, (t - t0) / ms);
                    const v = Math.round(start + diff * p);
                    ytPlayer.setVolume(v);
                    if (p < 1) requestAnimationFrame(step); else res();
                };
                requestAnimationFrame(step);
            });
        } catch(_) {}
    }
    async function ytFadeInPlay(ms=220) {
        try {
            const tgt = Math.max(0, Math.min(100, (data && data.settings && data.settings.youtubeVolume) || 80));
            if (!IS_FILE_PROTOCOL) {
                if (!ytPlayer) return;
                ytPlayer.unMute();
                ytPlayer.playVideo();
                try { ytPlayer.setVolume(0); } catch(_) {}
                await ytFadeTo(tgt, ms);
            } else {
                const vid = getActiveVideoId();
                if (vid) { fallbackLoadVideo(vid, {autoplay:1, mute:0}); }
            }
        } catch(_) {}
    }
    async function ytFadeOutPause(ms=180) {
        try {
            const tgt = Math.max(0, Math.min(100, (data && data.settings && data.settings.youtubeVolume) || 80));
            if (!IS_FILE_PROTOCOL) {
                if (!ytPlayer) return;
                await ytFadeTo(0, ms);
                try { ytPlayer.pauseVideo(); ytPlayer.setVolume(tgt); } catch(_) {}
            } else {
                try { fallbackPause(); } catch(_) {}
            }
        } catch(_) {}
    }
    async function updateYouTubePlayer() {
        const videoId = getActiveVideoId();
        if (data.settings.useYtThumbnailAsBg && videoId) {
            const thumbUrl = `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`;
            const img = new Image();
            img.onload = async () => { data.settings.customBg = thumbUrl; await saveData(); applyCustomBg(); };
            img.onerror = async () => { const fb = `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`; data.settings.customBg = fb; await saveData(); applyCustomBg(); };
            img.src = thumbUrl;
        } else if (!videoId) {
            data.settings.customBg = '';
            await saveData();
            applyCustomBg();
        }
        if (IS_FILE_PROTOCOL) {
            if (!videoId) { 
                fallbackStop();
                hideSoundPermission();
                return;
            }
            const isMuted = _ytUnlocked ? 0 : 1;
            fallbackLoadVideo(videoId, { autoplay: 1, mute: isMuted });
            if (!_ytUnlocked) {
                showSoundPermission();
            }
            return;
        }
        if (!ytPlayer || !ytPlayer.cueVideoById) { try { ensureYouTubeAPI(); } catch(_) {} return; }
        if (!videoId) {
            if (ytPlayer.stopVideo) ytPlayer.stopVideo();
            hideSoundPermission();
            return;
        }
        ytPlayer.cueVideoById(videoId);
        ytPlayer.setVolume(data.settings.youtubeVolume);
    }
    function toggleYtSound() {
        if (!_ytUnlocked) {
            try { ensureAudio(); } catch(_) {}
            try { unlockAudioChain(); } catch(_) {}
            return;
        }
        if (IS_FILE_PROTOCOL) {
            const vid = getActiveVideoId();
            if (!ytFallbackFrame || !ytFallbackFrame.isConnected) {
                if (!vid) { toast('Chưa có link hợp lệ. Dán link rồi bấm ▶️.'); return; }
                fallbackLoadVideo(vid, { autoplay: 1, mute: 0 });
                ytFallbackIsPlaying = true;
                try { const btn = document.getElementById('btnToggleYtSound'); if (btn) btn.textContent = '⏸️'; } catch(_) {}
                toast('Đang phát nhạc nền...');
                return;
            }
            if (ytFallbackIsPlaying) {
                fallbackPostMessage('pauseVideo');
                ytFallbackIsPlaying = false;
                toast('Đã dừng nhạc nền.');
            } else {
                if (!vid) { toast('Chưa có link hợp lệ. Dán link rồi bấm ▶️.'); return; }
                fallbackPostMessage('playVideo');
                ytFallbackIsPlaying = true;
                toast('Đang phát nhạc nền...');
            }
            try { 
                const btn = document.getElementById('btnToggleYtSound'); 
                if (btn) btn.textContent = ytFallbackIsPlaying ? '⏸️' : '▶️'; 
            } catch(_) {}
            return;
        }
        if (!ytPlayer || typeof ytPlayer.getPlayerState !== 'function') { try { ensureYouTubeAPI(); } catch(_) {} return; }
        const playerState = ytPlayer.getPlayerState();
        if (playerState === YT.PlayerState.PLAYING || playerState === YT.PlayerState.BUFFERING) {
            ytFadeOutPause();
            ytUserPaused = true;
            toast('Đã dừng nhạc nền.');
        } else {
            ytFadeInPlay();
            ytUserPaused = false;
            toast('Đang phát nhạc nền...');
        }
    }
    function bindEvents(){
      // Update welcome message copy
      try {
        const wp = document.querySelector('#welcomePanel p');
        if (wp) {
          wp.innerHTML = 'Hãy bắt đầu bằng cách chọn một <strong>Chủ đề con</strong> hoặc tạo Chủ đề.';
        }
      } catch(_) {}
      on($('#btnToggleBg'), 'click', toggleBackgroundView);
      on($('#btnMilestoneClose'), 'click', () => { $('#modalMilestone').classList.remove('show'); try { releaseFocus(); } catch(_) {} });
      on($('#btnAddTopic'), 'click', () => showInputModal('Tên Chủ đề mới?', async (name) => { if (!name) return; data.topics.push({ id: uid('t'), name, subtopics: [] }); await saveData(); renderTopics(); }));
      on($('#btnExport'), 'click', ()=> storageManager.exportData(data));
        on($("#importFile"), 'change', (e) => {
          const f = e.target.files[0];
          if (!f) return;
          storageManager.importData(f).then(async (d) => {
            data = d;
            normalizeDataStructure(data);
            await ensureValidSelection();
            await seedAchievedMilestones();
            toast('Đã nhập dữ liệu thành công!');
            renderAll();
          }).catch(err => toast('Nhập thất bại: ' + err.message));
          e.target.value = null;
        });
      on($('#btnRestoreBackup'), 'click', () => {
          const backupListEl = $('#backupList');
          const selectedDate = backupListEl ? backupListEl.value : '';
          if (!selectedDate) { toast('Vui lòng chọn một bản sao lưu.'); return; }
          showConfirmModal('Xác nhận phục hồi', `Bạn có chắc muốn phục hồi dữ liệu từ ngày ${new Date(selectedDate).toLocaleDateString()}? Dữ liệu hiện tại sẽ bị ghi đè.`, (ok) => {
              if (ok) {
                  storageManager.restoreBackup(selectedDate).then((d) => {
                      data = d;
                      toast('Phục hồi dữ liệu thành công! Tải lại trang...');
                      setTimeout(() => window.location.reload(), 1500);
                  }).catch(err => {
                      toast(`Lỗi: ${err.message}`);
                  });
              }
          });
      });
      on($('#set_theme_color'), 'input', (e) => {
          const selectedTheme = e.target.value;
          applyTheme(selectedTheme);
          if (selectedTheme === 'light' || selectedTheme === 'pastel') {
              const ytThumbCheckbox = $('#set_ytThumbAsBg');
              if (ytThumbCheckbox) {
                  ytThumbCheckbox.checked = false;
                  toast('Đã tắt nền YouTube để hợp với theme sáng.', 2000);
              }
              // Đảm bảo xem trước nền gốc cho theme sáng
              try { document.body.style.setProperty('--bg-image', 'none'); } catch(_) {}
          } else {
              // Theme tối: tự bật dùng thumbnail YouTube nếu có link
              const ytThumbCheckbox = $('#set_ytThumbAsBg');
              if (ytThumbCheckbox) {
                  ytThumbCheckbox.checked = true;
              }
              try { updateYouTubePlayer(); } catch(_) {}
          }
      });
      on($('#btnSettings'), 'click', openSettings);
      on($('#btnHelpCreateTopic'), 'click', () => {
          switchView('topics');
          $('#btnAddTopic').click();
      });
      on($('#btnDashboard'), 'click', () => {
          renderDashboard();
          $('#modalDashboard').classList.add('show');
      });
      on($('#btnCloseDashboard'), 'click', () => {
          $('#modalDashboard').classList.remove('show');
      });
      on($('#btnCloseSettings'), 'click', closeSettings);
      on($('#btnSaveSettings'), 'click', saveSettings);
      on($('#set_language'), 'change', (e) => {
        const newLang = e.target.value;
        loadLanguage(newLang);
        if (window.data && data.settings) { data.settings.language = newLang; saveData(); }
      });
      on($('#btnDefaults'), 'click', setDefaults);
      on($('#btnTestSound'), 'click', ()=>{ ensureAudio(); playSound('work_end'); });
      const customSoundsToggle = $('#set_useCustomSounds');
      if (customSoundsToggle) {
          on(customSoundsToggle, 'change', (e) => {
              const enabled = !!e.target.checked;
              const container = $('#customSoundsContainer');
              if (container) container.classList.toggle('hidden', !enabled);
          });
      }
      on($('#btnSaveNote'), 'click', async ()=>{ const s=getCurrentSubtopic(); if(!s) return; const id=pendingNoteSessionId; const sess=s.sessions.find(x=>x.id===id); if(sess){ sess.note=$('#noteText').value.trim(); await saveData(); renderStatsHistory(); toast('Đã lưu ghi chú'); } closeNoteModal(); });
      on($('#btnSkipNote'), 'click', ()=> closeNoteModal());
      on($('#btnAddGeneralNote'), 'click', addGeneralNote);
      on($('#btnSummarizeNote'), 'click', handleSummarizeNote);
      on($('#btnSendMessage'), 'click', handleSendMessage);
      on($('#chatInput'), 'keydown', (e) => { if (e.key === 'Enter') handleSendMessage(); });
      $$('#aiPromptSuggestions button').forEach(btn => {
        on(btn, 'click', () => {
          const promptTemplate = btn.dataset.prompt;
          $('#chatInput').value = promptTemplate;
          $('#chatInput').focus();
        });
      });
      on($('#btnClearChat'), 'click', clearChat);
      on($('#btnAddSubtopicTask'), 'click', addSubtopicTask);
      on($('#newSubtopicTaskInput'), 'keydown', (e) => { if (e.key === 'Enter') addSubtopicTask(); });
      on($('#btnToggleYtSound'), 'click', toggleYtSound);
      on($('#btnEnableSound'), 'click', () => { ensureAudio(); unlockAudioChain(); });
      on($('#ytSoundVolume'), 'input', (e) => {
          const vol = parseInt(e.target.value, 10);
          if (ytPlayer && ytPlayer.setVolume) {
              ytPlayer.setVolume(vol);
          }
      });
      on($('#set_youtubeUrl'), 'input', handleYoutubeUrlInput);
      // Removed performance mode toggle from settings
      
      // Pin timer menu removed per request
      // Nav buttons: toggle back to Timer on second click (guide, methods, topics, stats)
      $$('.nav-btn[data-view]').forEach(btn => {
        btn.addEventListener('click', () => {
          const view = btn.dataset.view;
          const cur = data?.settings?.currentView || 'timer';
          if (cur === view && view !== 'timer') switchView('timer');
          else switchView(view);
        });
      });
      $$('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const tabId = btn.dataset.tab;
                const parent = btn.closest('.aux-panel, .modal-card');
                if (!parent) return;
                parent.querySelectorAll('.tab-btn').forEach(t => t.classList.remove('active'));
                btn.classList.add('active');
                parent.querySelectorAll('.tab-content').forEach(c => {
                    c.classList.remove('active');
                    c.style.display = 'none';
                });
                const activeContent = parent.querySelector(`#${tabId}`);
                if(activeContent) {
                    activeContent.classList.add('active');
                    activeContent.style.display = 'block';
                    if(parent.closest('#modalSettings')) {
                        activeContent.style.display = 'flex';
                    }
                }
            });
        });
      // === Methods toolbar & actions ===
      const editorContent = $('#methodEditorContentInput');
      function formatDoc(command, value = null) {
        try { document.execCommand('styleWithCSS', false, true); } catch(_) {}
        try { document.execCommand(command, false, value); } catch(_) {}
        if (editorContent) editorContent.focus();
      }
      on($('#toolBold'), 'click', () => formatDoc('bold'));
      on($('#toolItalic'), 'click', () => formatDoc('italic'));
      on($('#toolH4'), 'click', () => formatDoc('formatBlock', '<h4>'));
      on($('#toolList'), 'click', () => formatDoc('insertOrderedList'));
      on($('#toolBullet'), 'click', () => formatDoc('insertUnorderedList'));
      // === Color Picker events ===
      const colorPickerWrapper = $('.color-picker-wrapper');
      const colorPalette = $('.color-palette');
      on($('#toolColor'), 'click', (e) => {
        if (!colorPalette) return;
        e.stopPropagation();
        colorPalette.classList.toggle('hidden');
      });
      $$('.color-swatch').forEach(swatch => {
        on(swatch, 'click', (e) => {
          e.preventDefault();
          const colorVar = swatch.dataset.color || '';
          let computedColor = colorVar;
          try {
            const m = colorVar.match(/--[a-zA-Z0-9_-]+/);
            if (m) computedColor = getComputedStyle(document.body).getPropertyValue(m[0]).trim();
          } catch(_) {}
          formatDoc('foreColor', computedColor);
          if (colorPalette) colorPalette.classList.add('hidden');
        });
      });
      on(document, 'click', (e) => {
        if (!colorPickerWrapper || !colorPalette) return;
        if (!colorPickerWrapper.contains(e.target) && !colorPalette.classList.contains('hidden')) {
          colorPalette.classList.add('hidden');
        }
      });
      function openMethodEditor(id){
        const s = getCurrentSubtopic();
        if (!s) { toast('Vui lòng chọn một Chủ đề con trước.'); return; }
        s.methods = Array.isArray(s.methods) ? s.methods : [];
        const list = s.methods;
        const m = id ? list.find(x => x.id === id) : null;
        $('#methodEditorId').value = (m && m.id) || '';
        $('#methodEditorTitle').textContent = m ? 'Chỉnh-sửa Tri thức' : 'Thêm Tri thức mới';
        $('#methodEditorTitleInput').value = (m && m.title) || '';
        const ed = $('#methodEditorContentInput');
        if (ed) ed.innerHTML = (m && m.content) || '';
        $('#modalMethodEditor').classList.add('show');
        try { trapFocus($('#modalMethodEditor')); } catch(_) {}
        // Enable/disable Auto Format depending on API key
        try {
          const autoBtn = $('#btnAutoFormat');
          if (autoBtn) {
            const hasApiKey = !!(data?.settings?.apiKey && data.settings.apiKey.trim());
            autoBtn.disabled = !hasApiKey;
            autoBtn.title = hasApiKey ? 'Dùng AI để tự động định dạng văn bản' : 'Vui lòng thêm Gemini API Key trong Cài đặt để sử dụng tính năng này.';
          }
        } catch(_) {}
      }
      on($('#btnCancelMethodEditor'), 'click', () => { $('#modalMethodEditor').classList.remove('show'); try { releaseFocus(); } catch(_) {} });
      on($('#btnSaveMethod'), 'click', async () => {
        const s = getCurrentSubtopic();
        if (!s) { toast('Vui lòng chọn một Chủ đề con trước.'); return; }
        s.methods = Array.isArray(s.methods) ? s.methods : [];
        const id = $('#methodEditorId').value || uid('m');
        const title = ($('#methodEditorTitleInput').value || '').trim();
        const ed = $('#methodEditorContentInput');
        const content = ed ? (ed.innerHTML || '') : '';
        const idx = s.methods.findIndex(x => x.id === id);
        const item = { id, title, content };
        if (idx >= 0) s.methods[idx] = item; else s.methods.unshift(item);
        await storageManager.update('subtopics', s);
        renderMethods();
        $('#modalMethodEditor').classList.remove('show');
        try { releaseFocus(); } catch(_) {}
      });
      on($('#btnAutoFormat'), 'click', async () => {
        const ed = $('#methodEditorContentInput');
        if (!ed) return;
        const plainText = (ed.textContent || '').trim();
        if (!plainText || plainText.length < 20) { toast('Cần có nội dung để AI định dạng.'); return; }
        const btn = $('#btnAutoFormat');
        if (btn) { btn.disabled = true; btn.innerHTML = '<div class="spinner"></div>'; }
        const prompt = `Phân tích và định dạng lại đoạn văn bản sau đây thành mã HTML sạch. Sử dụng các thẻ sau:\n- Dùng <h4> cho các tiêu đề chính.\n- Dùng <strong> để nhấn mạnh các thuật ngữ hoặc ý tưởng quan trọng.\n- Dùng <i> cho các câu ghi chú hoặc trích dẫn.\n- Dùng <ol> và <li> cho các danh sách có thứ tự.\n- Dùng <ul> và <li> cho các danh sách không có thứ tự.\n- Bọc các đoạn văn thông thường trong thẻ <p>.\nVăn bản cần định dạng:\n\n"${plainText}"`;
        const formattedHtml = await callGeminiAPI(prompt);
        if (formattedHtml) { ed.innerHTML = formattedHtml; toast('AI đã định dạng xong!'); }
        else { toast('AI không thể định dạng lúc này.'); }
        if (btn) { btn.disabled = false; btn.innerHTML = '✨ Tự động định dạng'; }
      });
      on($('#btnAddMethod'), 'click', () => {
        if (!getCurrentSubtopic()) { toast('Vui lòng chọn một Chủ đề con trước.'); return; }
        openMethodEditor();
      });
      const methodsView = document.querySelector('#view-methods');
      if (methodsView) {
        methodsView.addEventListener('click', (e) => {
          const editBtn = e.target.closest && e.target.closest('.method-edit');
          const delBtn = !editBtn && e.target.closest && e.target.closest('.method-delete');
          if (editBtn) {
            e.preventDefault(); e.stopPropagation();
            const id = editBtn.dataset.id;
            if (id) openMethodEditor(id);
            return;
          }
          if (delBtn) {
            e.preventDefault(); e.stopPropagation();
            const id = delBtn.dataset.id;
            if (!id) return;
            const s = getCurrentSubtopic();
            if (!s) return;
            s.methods = Array.isArray(s.methods) ? s.methods : [];
            const item = s.methods.find(x => x.id === id);
            if (!item) return;
            showConfirmModal('Xác nhận xóa', `Xóa tri thức "${item.title || ''}"?`, async (ok) => {
              if (!ok) return;
              s.methods = s.methods.filter(x => x.id !== id);
              await storageManager.update('subtopics', s);
              renderMethods();
            });
          }
        });
      }
        $$('#timerPresetSelector button').forEach(btn => {
          btn.addEventListener('click', () => {
            editingPreset = btn.dataset.presetTarget;
            highlightPresetSelector();
            loadEditingPresetFields();
          });
        });
      $$('.presets button').forEach(button => {
        button.addEventListener('click', (e) => {
          const newPreset = e.target.dataset.preset;
          const currentPreset = data.settings.preset;
          if (newPreset === currentPreset) {
            return;
          }
          if (timer.state !== 'idle') {
            showConfirmModal(
              'Xác nhận chuyển đổi',
              `Bạn có chắc muốn chuyển sang Kiểu ${newPreset}? Thao tác này sẽ dừng và đặt lại phiên làm việc hiện tại.`,
              (confirmed) => {
                if (confirmed) {
                  timer.reset();
                  timer.setPreset(newPreset);
                  renderAll();
                  toast(`Đã chuyển sang Kiểu ${newPreset}.`);
                }
              }
            );
          } 
          else {
            timer.setPreset(newPreset);
            renderAll();
            toast(`Đã chuyển sang Kiểu ${newPreset}.`);
          }
        });
      });
      on($('#btnStart'), 'click', ()=> timer.start());
      on($('#btnFinishFlow'), 'click', ()=> timer.finishFlowSession());
      on($('#btnPause'), 'click', ()=> timer.pause());
      on($('#btnResume'), 'click', ()=> timer.resume());
      on($('#btnSkip'), 'click', ()=> timer.skip());
      on($('#btnReset'), 'click', ()=> timer.reset());
      on($('#btnBreakEarly'), 'click', ()=> timer.beginBreak());
      on($('#uploadBg'), 'change', (e) => { handleFileUpload(e.target.files[0], async (id) => { data.settings.customBg = id; await saveData(); applyCustomBg(); toast("Đã cập nhật hình nền."); }); e.target.value = null; });
      on($('#btnClearBg'), 'click', async () => {
          data.settings.customBg = '';
          data.settings.useYtThumbnailAsBg = false;
          await saveData();
          applyCustomBg();
          toast("Đã xóa hình nền tùy chỉnh.");
          if ($('#modalSettings').classList.contains('show')) {
              openSettings();
          }
      });
      
      on($('#uploadSoundWork'), 'change', (e) => { handleFileUpload(e.target.files[0], async (id) => { data.settings.customSounds.work_end = id; await saveData(); toast("Đã lưu âm báo hết LÀM VIỆC."); }); e.target.value = null; });
      on($('#uploadSoundBreak'), 'change', (e) => { handleFileUpload(e.target.files[0], async (id) => { data.settings.customSounds.break_end = id; await saveData(); toast("Đã lưu âm báo hết NGHỈ NGẮN."); }); e.target.value = null; });
      on($('#uploadSoundLong'), 'change', (e) => { handleFileUpload(e.target.files[0], async (id) => { data.settings.customSounds.long_end = id; await saveData(); toast("Đã lưu âm báo hết NGHỈ DÀI."); }); e.target.value = null; });
      on($('#btnFullscreen'), 'click', toggleFullScreen);
      document.addEventListener('fullscreenchange', updateFullscreenButton);
      window.addEventListener('keydown', (e)=>{
        const target = e.target;
        const tag = (target.tagName||'').toLowerCase();
        const isTyping = ['input','textarea','select'].includes(tag) || target.isContentEditable;
        if(e.code==='Space' && !isTyping){
          e.preventDefault();
          if(timer.state==='idle'||timer.state==='paused') timer.start(); else timer.pause();
        }
        if(e.key==='n'||e.key==='N'){
          if(!isTyping){ e.preventDefault(); timer.skip(); }
        }
        if(e.key==='Escape'){
          $$('.modal').forEach(m => m.classList.remove('show'));
          try { releaseFocus(); } catch(_) {}
        }
        if(e.altKey && !isTyping){
          if(e.key==='ArrowUp'){ e.preventDefault(); nudgeTimer(0,-10); }
          else if(e.key==='ArrowDown'){ e.preventDefault(); nudgeTimer(0,10); }
          else if(e.key==='ArrowLeft'){ e.preventDefault(); nudgeTimer(-10,0); }
          else if(e.key==='ArrowRight'){ e.preventDefault(); nudgeTimer(10,0); }
        }
      });
      $$('.modal').forEach(m=> m.addEventListener('click', (ev)=>{
        // Đừng đóng Modal Method Editor khi click nền
        if (ev && ev.target && ev.target.id === 'modalMethodEditor') return;
        if(ev.target===m){ m.classList.remove('show'); try { releaseFocus(); } catch(_) {} }
      }));
      window.addEventListener('click', (e) => {
        if (!e.target.closest('.actions-menu-btn') && !e.target.closest('.actions-menu')) {
            closeAllMenus();
        }
      });
      // Đóng menu khi cuộn nội dung để tránh sai lớp chồng
      try {
        const appContent = document.querySelector('.app-content');
        if (appContent) appContent.addEventListener('scroll', closeAllMenus);
      } catch(_) {}
      try { window.addEventListener('scroll', closeAllMenus, true); } catch(_) {}
      window.addEventListener('beforeunload', () => timer.persistTimerState(true));

      // Accordion behavior for Methods section (always single-open)
      try {
        const methodItems = Array.from(document.querySelectorAll('#view-methods .method-item'));
        if (methodItems.length) {
          methodItems.forEach(item => {
            item.addEventListener('toggle', () => {
              if (item.open) {
                methodItems.forEach(other => { if (other !== item) other.open = false; });
              }
            });
          });
        }
      } catch(_) {}
      const draggableElement = $('#draggableTimer');
      let isDragging = false;
      let offsetX, offsetY;
      if (draggableElement) {
        draggableElement.addEventListener('mousedown', (e) => {
          isDragging = true;
          const rect = draggableElement.getBoundingClientRect();
          offsetX = e.clientX - rect.left;
          offsetY = e.clientY - rect.top;
          draggableElement.style.transition = 'none';
        });
        document.addEventListener('mousemove', (e) => {
          if (!isDragging) return;
          let newX = e.clientX - offsetX;
          let newY = e.clientY - offsetY;
          const boundaryX = window.innerWidth - draggableElement.offsetWidth;
          const boundaryY = window.innerHeight - draggableElement.offsetHeight;
          newX = Math.max(0, Math.min(newX, boundaryX));
          newY = Math.max(0, Math.min(newY, boundaryY));
          draggableElement.style.left = newX + 'px';
          draggableElement.style.top = newY + 'px';
          draggableElement.style.bottom = 'auto';
          draggableElement.style.right = 'auto';
        });
        document.addEventListener('mouseup', () => {
          if (!isDragging) return;
          isDragging = false;
          draggableElement.style.transition = '';
        });
      }
      function pinTimerCorner(pos){
        const el = $('#draggableTimer'); if (!el) return;
        el.style.position = 'fixed';
        el.style.transition = '';
        el.style.left = 'auto'; el.style.top = 'auto'; el.style.right = 'auto'; el.style.bottom = 'auto';
        const m = 16; // margin
        if (pos === 'tl') { el.style.left = m+'px'; el.style.top = m+'px'; }
        if (pos === 'tr') { el.style.right = m+'px'; el.style.top = m+'px'; }
        if (pos === 'bl') { el.style.left = m+'px'; el.style.bottom = m+'px'; }
        if (pos === 'br') { el.style.right = m+'px'; el.style.bottom = m+'px'; }
      }
      function nudgeTimer(dx, dy){
        const el = $('#draggableTimer'); if (!el) return;
        const rect = el.getBoundingClientRect();
        const nx = Math.max(0, Math.min((rect.left + dx), window.innerWidth - el.offsetWidth));
        const ny = Math.max(0, Math.min((rect.top + dy), window.innerHeight - el.offsetHeight));
        el.style.left = nx + 'px'; el.style.top = ny + 'px';
        el.style.right = 'auto'; el.style.bottom = 'auto';
      }
    }
    function toggleBackgroundView(){
        const body = document.body;
        body.classList.toggle('bg-view-mode');
        const isActive = body.classList.contains('bg-view-mode');
        const btn = $('#btnToggleBg');
        if (!btn) return;
        if (isActive) {
            btn.title = 'Hiện giao diện';
            btn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9.88 9.88a3 3 0 1 0 4.24 4.24"/><path d="M10.73 5.08A10.43 10.43 0 0 1 12 5c7 0 10 7 10 7a13.16 13.16 0 0 1-1.67 2.68"/><path d="M6.61 6.61A13.526 13.526 0 0 0 2 12s3 7 10 7a9.74 9.74 0 0 0 5.39-1.61"/><line x1="2" y1="2" x2="22" y2="22"/></svg>`;
        } else {
            btn.title = 'Ẩn giao diện';
            btn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/></svg>`;
        }
    }
    function updateMainViewVisibility() {
        const hasSubtopic = !!getCurrentSubtopic();
        const timerView = $('#view-timer');
        const welcomePanel = $('#welcomePanel');
        if (welcomePanel) {
            welcomePanel.classList.toggle('hidden', hasSubtopic);
        }
        if (timerView) {
            if (hasSubtopic) {
                timerView.classList.remove('no-subtopic-selected');
            } else {
                timerView.classList.add('no-subtopic-selected');
            }
        }
    }
    function updatePresetButtonsText() {
        const settings = data.settings;
        const cyclesA = settings.cyclesA;
        const cyclesB = settings.cyclesB;
        const workA = settings.durations.A_work;
        const workB = settings.durations.B_work;
        const btnA = $('#btnPresetA');
        const btnB = $('#btnPresetB');
        const btnC = $('#btnPresetC');
        if (btnA) {
            btnA.textContent = `${cyclesA}×${workA} (A)`;
        }
        if (btnB) {
            btnB.textContent = `${cyclesB}×${workB} (B)`;
        }
        if (btnC) {
            btnC.textContent = '🌊 Flow';
        }
    }
    function renderAll(){
        updatePresetButtonsText();
        const currentPreset = data.settings.preset;
        $$('.presets button').forEach(button => {
          const isSelected = button.dataset.preset === currentPreset;
          button.classList.toggle('acc', isSelected);
          button.classList.toggle('ghost', !isSelected);
          button.setAttribute('aria-pressed', isSelected);
        });
        updateMainViewVisibility();
        timer.setPreset(data.settings.preset, {silent:true});
        renderTopics();
        renderContextBadge();
        renderStatsHistory();
        renderGeneralNotes();
        renderMethods();
        renderChat();
        applyCustomBg();
        applyPanelOpacity();
        renderSubtopicTasks();
        updateFullscreenButton();
        switchView(data.settings.currentView);
        // fixVietnameseUI đã bị loại bỏ; nội dung hiển thị trực tiếp bằng UTF-8
    }
    function toggleFullScreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(err => {
                toast(`Lỗi: Không thể bật chế độ toàn màn hình: ${err.message}`);
            });
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            }
        }
    }
    function updateFullscreenButton() {
        const btn = $('#btnFullscreen');
        if (document.fullscreenElement) {
            btn.innerHTML = '↙️';
            btn.title = 'Thoát toàn màn hình';
        } else {
            btn.innerHTML = '↗️';
            btn.title = 'Toàn màn hình';
        }
    }
    async function initializeApp() {
      try {
        await storageManager.initDB();
        const [settings, topics, subtopics] = await Promise.all([
          storageManager.getSettings(),
          storageManager.getAll('topics'),
          storageManager.getAll('subtopics')
        ]);
        let merged;
        if (!settings) {
          const defaultData = JSON.parse(JSON.stringify(defaults));
          await storageManager.updateSettings(defaultData.settings);
          // Seed any default topics/subtopics if provided
          for (const t of defaultData.topics) {
            const { subtopics: subs, ...topicData } = t;
            await storageManager.add('topics', topicData);
            for (const sub of subs) {
              await storageManager.add('subtopics', { ...sub, topicId: t.id });
            }
          }
          merged = defaultData;
        } else {
          const map = {};
          for (const t of topics) map[t.id] = { ...t, subtopics: [] };
          for (const s of subtopics) map[s.topicId]?.subtopics.push(s);
          merged = { version: defaults.version, settings, topics: Object.values(map) };
        }
        data = window.data = merged;
        normalizeDataStructure(data);
        await ensureValidSelection();
        await seedAchievedMilestones();
        renderAll();
        try { tagI18nElements(); applyLanguage(data.settings?.language || localStorage.getItem('lang') || 'vi'); } catch(_) {}
        try { storageManager.autoBackup(data); } catch (e) { console.warn('AutoBackup error:', e); }
        bindEvents();
        applyTheme();
      } catch (err) {
        console.error('Initialization error:', err);
        toast(`Lỗi khởi tạo: ${err.message}`);
      }
    }
    // =========================================================
    // START: SMART API KEY LOAD BALANCER (DEVELOPER KEYS)
    // =========================================================

    // !!! QUAN TRỌNG: Dán 5 API key của bạn vào đây !!!
    const DEV_API_KEYS = [
        "AIzaSyD8E1bD0QNkUGlq7MKKkp9eNsaOcQyfhPc", // Thay thế bằng key 1
        "AIzaSyCt7WR2hjW2GPxMWDQio8oq6s_DWx_Xw3c", // Thay thế bằng key 2
        "AIzaSyAUHA8NhgR1HZJHdSY5PpDazk9TYtEzPK4", // Thay thế bằng key 3
        "AIzaSyDq7pp49556F9sNCoKI-yKasvwQITe88ZQ", // Thay thế bằng key 4
        "AIzaSyBPSxO2QIFhgc9vcytVVNO_CYPUShPTCRc" // Thay thế bằng key 5
    ].filter(Boolean); // Lọc ra các key rỗng (nếu bạn dán thiếu)

    const geminiKeyManager = {
        health: {}, // Lưu trạng thái: { "key_string": { healthy: true } }

        /**
         * Khởi tạo trạng thái health cho các key
         */
        initializeHealth: function() {
            this.health = {};
            for (const key of DEV_API_KEYS) {
                // Đảm bảo key là string và không rỗng
                if (typeof key === 'string' && key.trim()) {
                    this.health[key.trim()] = { healthy: true };
                }
            }
        },

        /**
         * Chọn key tốt nhất (ưu tiên key "healthy")
         */
        selectBestKey: function() {
            const validKeys = DEV_API_KEYS.filter(k => k && this.health[k]);
            if (validKeys.length === 0) return null;

            const healthyKeys = validKeys.filter(k => this.health[k]?.healthy);
            
            if (healthyKeys.length > 0) {
                // Đơn giản là chọn key đầu tiên trong danh sách healthy
                return healthyKeys[0]; 
            }

            // Nếu tất cả đều unhealthy, thử reset và chọn lại
            console.warn("Tất cả Gemini keys đều bị đánh dấu unhealthy. Reset và thử lại...");
            this.resetHealth(); // Reset tất cả về 'healthy: true'
            
            // Nếu sau khi reset vẫn có key, trả về key đầu tiên
            const resetKeys = DEV_API_KEYS.filter(k => k && this.health[k]);
            if (resetKeys.length > 0) return resetKeys[0];

            return null; // Thực sự không có key nào
        },

        /**
         * Báo cáo lỗi cho một key (ví dụ: lỗi 429 - hết quota)
         */
        reportFailure: function(key) {
            if (this.health[key]) {
                this.health[key].healthy = false;
                console.warn(`Gemini key ...${key.slice(-4)} bị đánh dấu unhealthy.`);
            }
        },

        /**
         * Báo cáo key hoạt động thành công
         */
        reportSuccess: function(key) {
            if (this.health[key]) {
                this.health[key].healthy = true;
            }
        },

        /**
         * Reset health của tất cả key (để thử lại sau một thời gian)
         */
        resetHealth: function() {
            Object.keys(this.health).forEach(k => {
                if(this.health[k]) this.health[k].healthy = true;
            });
            if (Object.keys(this.health).length > 0) {
                console.log("Trạng thái Gemini key health đã được reset.");
            }
        }
    };

    // Khởi tạo trạng thái health ngay khi tải
    geminiKeyManager.initializeHealth();

    // Tự động reset health của các key mỗi 30 phút
    // (Giống logic "Health monitoring" trong ví dụ của bạn)
    setInterval(() => {
        geminiKeyManager.resetHealth();
    }, 1800000); // 30 phút

    /**
     * Hàm gọi API MỚI với logic Smart Load Balancing
     * @param {string} prompt - Câu lệnh prompt
     * @param {Set<string>} visitedKeys - (Chỉ dùng nội bộ) để tránh vòng lặp vô hạn
     */
    callGeminiAPI = async function(prompt, visitedKeys = new Set()) {
        
        // 1. Chọn key tốt nhất
        const apiKey = geminiKeyManager.selectBestKey();

        if (!apiKey) {
            // Trường hợp này chỉ xảy ra nếu mảng DEV_API_KEYS bị rỗng
            toast("Lỗi: Chưa cấu hình API key phía nhà phát triển.", 4000);
            return null;
        }

        // 2. Kiểm tra vòng lặp (nếu đã thử key này trong 1 chuỗi failover)
        if (visitedKeys.has(apiKey)) {
            // Đã thử hết tất cả các key và quay lại key đầu tiên -> tất cả đều hỏng
            toast("Tất cả API keys đều không khả dụng. Vui lòng thử lại sau.", 4000);
            geminiKeyManager.resetHealth(); // Reset cho lần gọi tiếp theo
            return null;
        }
        visitedKeys.add(apiKey); // Đánh dấu đã thử key này

        // 3. Thực hiện cuộc gọi API
        // (Sử dụng model và URL giống như trong file 02.html gốc của bạn)
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
        const payload = { contents: [{ role: "user", parts: [{ text: prompt }] }] };

        try {
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });

            if (!response.ok) {
                // 4. Xử lý lỗi & TỰ ĐỘNG FAILOVER
                let errorMsg = `Lỗi API Key ...${apiKey.slice(-4)}`;

                if (response.status === 429) { // Rate limit (Hết Quota)
                    errorMsg = `Key ...${apiKey.slice(-4)} hết quota. Tự động chuyển key...`;
                    console.warn(errorMsg);
                    toast(errorMsg, 2500);
                } else if (response.status === 400) { // Bad key (Key sai)
                    errorMsg = `Lỗi: Key ...${apiKey.slice(-4)} không hợp lệ. Tự động chuyển key...`;
                    toast(errorMsg, 3000);
                } else { // Lỗi khác (Server 500,...)
                    errorMsg = `Lỗi máy chủ (${response.status}) với key ...${apiKey.slice(-4)}. Tự động chuyển key...`;
                    console.error("Gemini API Error:", await response.text());
                }
                
                geminiKeyManager.reportFailure(apiKey); // Đánh dấu key này là hỏng
                return callGeminiAPI(prompt, visitedKeys); // Đệ quy để thử key khác
            }

            // 5. THÀNH CÔNG
            const result = await response.json();
            geminiKeyManager.reportSuccess(apiKey); // Báo cáo key này OK

            if (result.candidates && result.candidates[0]?.content?.parts?.[0]?.text) {
                return formatGeminiResponse(result.candidates[0].content.parts[0].text);
            } else {
                console.error("API response structure is unexpected:", result);
                if (result.promptFeedback?.blockReason) { return `Nội dung bị chặn vì: ${result.promptFeedback.blockReason}. Vui lòng thử lại với nội dung khác.`; }
                return "Không nhận được nội dung hợp lệ từ AI.";
            }

        } catch (error) {
            // 6. LỖI MẠNG (Fetch failed) & TỰ ĐỘNG FAILOVER
            console.error("Lỗi mạng khi gọi Gemini API:", error);
            toast("Lỗi mạng khi kết nối. Tự động chuyển key...", 3000);
            geminiKeyManager.reportFailure(apiKey); // Đánh dấu key hỏng
            return callGeminiAPI(prompt, visitedKeys); // Thử key khác
        }
    }

    // =========================================================
    // END: SMART API KEY LOAD BALANCER
    // =========================================================

    loadLanguage(localStorage.getItem('lang') || 'vi').then(initializeApp);
    </script>
</body>
</html>

